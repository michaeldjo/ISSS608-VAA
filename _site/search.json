[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About this site",
    "section": "",
    "text": "This website consists of a collection of works done for the visual analytics course I took during my MITB journey. You can treat this as a portfolio of my work.\nThe visualisation work is done with Tableau, R packages and Shiny app.\nThere are four types of exercise:\n\nHands-on Exercise\nTrying out new visualisation skills and technique\nIn-Class Exercise\nRelevant notes from lecture by Prof. Kam Tin Seong\nTake-home Exercise\nApplication of skills learned in class in real-life problems"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "The code chunk below uses p_load() of pacman package to check if tidyverse packages are installed in the computer. If they are, then they will be launched into R.\n\npacman::p_load(tidyverse)\n\n\n\n\n\nexam_data <- read_csv(\"data/Exam_data.csv\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#try-it-yourself-exercise",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#try-it-yourself-exercise",
    "title": "Hands-on Exercise 1",
    "section": "2. Try-It-Yourself Exercise",
    "text": "2. Try-It-Yourself Exercise\n\nWorking with facet\nExample 1 Plotting trellis boxplot using facet_wrap by GENDER\n\nggplot(data = exam_data,\n       aes(x = CLASS,\n           y = MATHS)) +\n  geom_boxplot() +\n  facet_wrap(~ GENDER)\n\n\n\n\nExample 2 Plotting trellis boxplot using facet_grid by GENDER\n\nggplot(data = exam_data,\n       aes(x = CLASS,\n           y = MATHS)) +\n  geom_boxplot() +\n  facet_grid(GENDER ~ .)\n\n\n\n\nExample 3 Plotting 2-D trellis boxplot using facet_grid\n\nggplot(data = exam_data,\n       aes(x = GENDER,\n           y = MATHS)) +\n  geom_boxplot() +\n  facet_grid(GENDER ~ CLASS)\n\n\n\n\n\n\nWorking with theme\nExample 4 Changing theme of bar plot\n\nggplot(data=exam_data, \n       aes(x=RACE)) +\n  geom_bar() +\n  coord_flip() +\n  theme(panel.background = element_rect(fill = \"light blue\"),\n        panel.grid = element_line(color = \"white\"))\n\n\n\n\n\n\nDesigning Data-driven Graphics for Analysis\nExercise 1\n\nggplot(data=exam_data, \n       aes(x = fct_infreq(RACE))) +\n  geom_bar() +\n  geom_text(stat = \"count\", \n            aes(label = paste0(after_stat(count), \", \",\n                        round(after_stat(count)/sum(after_stat(count))*100,\n                        1), \"%\")), \n            vjust = -1) +\n  labs(\n    x = \"Race\",\n    y = \"No. of\\nPupils\") +\n  theme(axis.title.y = element_text(angle = 0))\n\n\n\n\nExercise 2\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 color = \"black\",\n                 fill = \"light blue\") +\n  geom_vline(aes(xintercept = mean(MATHS)),\n             linetype = \"dashed\",\n             color = \"red\") +\n  geom_vline(aes(xintercept = median(MATHS)),\n             linetype = \"dashed\",\n             color = \"black\")\n\n\n\n\nExercise 3\n\nggplot(data = exam_data,\n       aes(x = ENGLISH)) +\n  geom_histogram(data = exam_data |> select(ENGLISH), \n                 bins = 30,\n                 alpha = 0.3) +\n  geom_histogram(aes(fill = GENDER),\n                 bins = 30,\n                 color = \"black\",\n                 show.legend = FALSE) +\n  facet_grid(~ GENDER) +\n  theme_bw()\n\n\n\n\nExercise 4\n\nggplot(data = exam_data,\n       aes(y = ENGLISH,\n           x = MATHS)) +\n  geom_point() +\n  coord_cartesian(xlim = c(0,100),\n                  ylim = c(0,100)) +\n  geom_vline(aes(xintercept = 50),\n             linetype = \"dashed\",\n             color = \"grey40\") +\n  geom_hline(aes(yintercept = 50),\n             linetype = \"dashed\",\n             color = \"grey40\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html",
    "href": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html",
    "title": "Hands-on Exercise 2: Creating Elegant Graphics with ggplot2",
    "section": "",
    "text": "The code chunk below uses p_load() of pacman package to check if packages are installed in the computer. If they are, then they will be launched into R.\n\npacman::p_load(tidyverse, ggdist, ggridges, \n               patchwork, ggthemes, hrbrthemes, \n               ggrepel, ggforce)\n\n\n\n\n\nexam_data <- read_csv(\"data/Exam_data.csv\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#exercises",
    "href": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#exercises",
    "title": "Hands-on Exercise 2: Creating Elegant Graphics with ggplot2",
    "section": "2. Exercises",
    "text": "2. Exercises\n\n2.1 Working with ggrepel\nggrepel helps to repel overlapping text\n\nggplot(data = exam_data,\n       aes(x = MATHS,\n           y = ENGLISH)) +\n  geom_point() +\n  geom_smooth(method = lm,\n              linewidth = 0.5) +\n  geom_label_repel(aes(label = ID),\n                   fontface = \"bold\") +\n  coord_cartesian(xlim = c(0,100),\n                  ylim = c(0,100)) +\n  ggtitle(\"English scores versus Maths scores for Primary 3\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: ggrepel: 317 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\n\n\n2.2 Working with themes\n8 Built-in themes: theme_gray(), theme_bw(), theme_classic(), theme_dark(), theme_light(), theme_linedraw(), theme_minimal(), and theme_void(). Refer to here Example below\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 boundary = 100,\n                 color = \"grey25\",\n                 fill = \"grey90\") +\n  theme_gray() +\n  ggtitle(\"Ditribution of Maths scores\")\n\n\n\n\nUnique ggtheme packages. Refer to here for more details on ggthemes package\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 boundary = 100,\n                 color = \"grey25\",\n                 fill = \"grey90\") +\n  theme_economist() +\n  ggtitle(\"Ditribution of Maths scores\")\n\n\n\n\nUnique hrbrthemes packages. This focuses more on the typographic elements, labels and fonts. However, it is mostly used for “production workflow”, where the intent is for the output of your work to be put into a publication of some kind, whether it be a blog post, academic paper, presentation, internal report or industry publication.\nRefer to here for more details on hrbrthemes package\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 boundary = 100,\n                 color = \"grey25\",\n                 fill = \"grey90\") +\n  theme_ipsum(axis_title_size = 18,          #increase font size of the axis title to 18\n              base_size = 15,                #increase the default axis label to 15\n              grid = \"Y\") +                  #only keep the y-axis grid line -> remove the x-axis grid lines\n  ggtitle(\"Ditribution of Maths scores\")\n\n\n\n\n\n\n2.3 Working with patchwork\nCreating composite plot by combining multiple graphs.\nStart with creating three statistical graphics below\n\n#creating histogram\np1 <- ggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 boundary = 100,\n                 color = \"grey25\",\n                 fill = \"grey90\") +\n  coord_cartesian(xlim = c(0,100)) +\n  ggtitle(\"Ditribution of Maths scores\")\n\np2 <- ggplot(data = exam_data,\n       aes(x = ENGLISH)) +\n  geom_histogram(bins = 20,\n                 boundary = 100,\n                 color = \"grey25\",\n                 fill = \"grey90\") +\n  coord_cartesian(xlim = c(0,100)) +\n  ggtitle(\"Ditribution of English scores\")\n\n#creating scatterplot\np3 <- ggplot(data = exam_data,\n       aes(x = MATHS,\n           y = ENGLISH)) +\n  geom_point() +\n  geom_smooth(method = lm,\n              linewidth = 0.5) +\n  coord_cartesian(xlim = c(0,100),\n                  ylim = c(0,100)) +\n  ggtitle(\"English scores versus Maths scores for Primary 3\")\n\nCreating patchwork.\n\nUse ‘+’ sign to create two columns layout\nUse ‘/’ sign to create two row layout (stack)\nUse ‘()’ sign to create subplot group\nUse ‘|’ sign to place the plots besisde each other\n\nRefer to here for more details. Examples below\n\np1 + p2 / p3\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n(p1 / p2) | p3\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n((p1 / p2) | p3) +\n  plot_annotation(tag_levels = 'I')\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n#this will auto-tag the subplots in text\n\nCombining patchwork and themes\n\n((p1 / p2) | p3) & theme_economist()\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n#this will auto-tag the subplots in text\n\nInsert another plot in a plot\n\np3 + inset_element(p2,\n                   left = 0.02,\n                   bottom = 0.7,\n                   right = 0.5,\n                   top = 1)\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03.html",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03.html",
    "title": "Hands-on Exercise 3: Programming Interactive Data Visualisation with R",
    "section": "",
    "text": "The code chunk below uses p_load() of pacman package to check if packages are installed in the computer. If they are, then they will be launched into R. The R packages installed are:\n\nggiraph for making ‘ggplot’ graphics interactive.\nplotly, R library for plotting interactive statistical graphs.\ngganimate, an ggplot extension for creating animated statistical graphs.\nDT provides an R interface to the JavaScript library DataTables that create interactive table on html page.\ntidyverse, a family of modern R packages specially designed to support data science, analysis and communication task including creating static statistical graphs.\npatchwork for compising multiple plots.\ngifski converts video frames to GIF animations using pngquant’s fancy features for efficient cross-frame palettes and temporal dithering. It produces animated GIFs that use thousands of colors per frame.\ngapminder: An excerpt of the data available at Gapminder.org. We just want to use its country_colors scheme.\n\n\npacman::p_load(ggiraph, plotly, gganimate, DT, tidyverse, patchwork, gifski, gapminder, readxl, rPackedBar)\n\n\n\n\n\nexam_data <- read_csv(\"data/Exam_data.csv\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03.html#exercises",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03.html#exercises",
    "title": "Hands-on Exercise 3: Programming Interactive Data Visualisation with R",
    "section": "2. Exercises",
    "text": "2. Exercises\n\n2.1 Using ggiraph for interactive data visualization\nggiraph is an htmlwidget and a ggplot2 extension. It allows ggplot graphics to be interactive. The interactivity is made with ggplot geometries that can understand three arguments:\n\nTooltip: a column of data-sets that contain tooltips to be displayed when the mouse is over elements.\nData_id: a column of data-sets that contain an id to be associated with elements.\nOnclick: a column of data-sets that contain a JavaScript function to be executed when elements are clicked.\n\nIf it is used within a shiny application, elements associated with an id (data_id) can be selected and manipulated on client and server sides.\n\n2.1.1 Using tooltip (tooltip effect)\nThere are two parts of the codes: 1. creating ggplot object, 2. girafe() of ggiraph will be used to create an interactive svg object.\n\nmy_plot <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n  \n  #geom_dotplot_interactive still takes argument of original geom_dotplot but with tooltip enabled in aes()\n  geom_dotplot_interactive(\n    aes(tooltip = ID),\n    stackgroups = TRUE,\n    binwidth = 1,\n    method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(\n  ggobj = my_plot,\n  width_svg = 6,\n  height_svg = 6*0.618\n)\n\n\n\n\n\nInteractivity: By hovering the mouse pointer on an data point of interest, the student’s ID will be displayed.\n\n\n2.1.2 Displaying multiple information on tooltip\nWhat if we want to display Student ID and Class while hovering with tooltip?\n\n#Creating new field called tooltip\nexam_data$tooltip <- c(paste0(\n  \"Name = \", exam_data$ID,\n  \"\\n Class\", exam_data$CLASS\n))\n\nmy_plot2 <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n  \n  geom_dotplot_interactive(\n    aes(tooltip = exam_data$tooltip),         #refer to the tooltip field above\n    stackgroups = TRUE,\n    binwidth = 1,\n    method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(\n  ggobj = my_plot2,\n  width_svg = 8,\n  height_svg = 8*0.618\n)\n\n\n\n\n\nInteractivity: By hovering the mouse pointer on an data point of interest, the student’s ID and Class will be displayed.\n\n\n2.1.3 Customising tooltip style\nUsing opts_tooltip to customise tooltip rendering by adding css declaration\n\ntooltip_css <- \"background-color:white; font-style:bold; color:red;\"\n\nmy_plot3 <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n  \n  geom_dotplot_interactive(\n    aes(tooltip = ID),\n    stackgroups = TRUE,\n    binwidth = 1,\n    method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(\n  ggobj = my_plot3,\n  width_svg = 6,\n  height_svg = 6*0.618,\n  options = list(\n    opts_tooltip(\n      css = tooltip_css)\n  )\n)\n\n\n\n\n\nNote: Background color is now white and the font color is red and bold\n\n\n2.1.4 Displaying statistics on tooltip\nIn this example, a function is used to compute 90% confident interval of the mean. The derived statistics are then displayed in the tooltip. This is created by creating a function\n\ntooltip_fn <- function(y, ymax, accuracy = .01) {   \n  mean <- scales::number(y, accuracy = accuracy) \n  sem <- scales::number(ymax - y, accuracy = accuracy) \n  paste(\"Mean maths scores:\", mean, \"+/-\", sem)                      \n} \n\ngg_point <- ggplot(data = exam_data,\n            aes(x = RACE)) +\n  \n  stat_summary(\n    aes(y = MATHS, \n        tooltip = after_stat(\n          tooltip_fn(y, ymax))),\n    fun.data = \"mean_se\",\n    geom = GeomInteractiveCol,\n    fill = \"lightblue\"\n    ) +\n  \n  stat_summary(\n    aes(y = MATHS),\n    fun.data = \"mean_se\",\n    geom = \"errorbar\", width = 0.2, size = 0.2\n  )\n\ngirafe(\n  ggobj = gg_point,\n  width_svg = 8,\n  height_svg = 8*0.618,\n  )\n\n\n\n\n\n\n\n2.1.5 Using data_id (hover effect)\n\nmy_plot <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n\n  geom_dotplot_interactive(\n    aes(data_id = CLASS),\n    stackgroups = TRUE,\n    binwidth = 1,\n    method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(\n  ggobj = my_plot,\n  width_svg = 6,\n  height_svg = 6*0.618\n)\n\n\n\n\n\nInteractivity: Elements associated with a data_id (i.e CLASS) will be highlighted upon mouse over. Note that the default value of the hover css is hover_css = “fill:orange;”.\n\n\n2.1.6 Customising hover effect style\nUsing css declaration to change the highlighting effect\n\nmy_plot2 <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n\n  geom_dotplot_interactive(\n    aes(data_id = CLASS),\n    stackgroups = TRUE,\n    binwidth = 1,\n    method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(\n  ggobj = my_plot2,\n  width_svg = 6,\n  height_svg = 6*0.618,\n  options = list(\n    opts_hover(css = \"fill: pink;\"),\n    opts_hover_inv(css = \"opacity:0.2;\")\n  )\n)\n\n\n\n\n\nInteractivity: Elements associated with a data_id (i.e CLASS) will be highlighted upon mouse over. Notice opts_hover refers to the selected data and opts_hover_inv refers to the non-selected data. Different from section 2.1.3 above, the css customisation request are encoded directly.\n\n\n2.1.7 Combining tooltip and hover effect\n\nmy_plot_comb <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n\n  geom_dotplot_interactive(\n    aes(tooltip = CLASS,\n        data_id = CLASS),\n    stackgroups = TRUE,\n    binwidth = 1,\n    method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(\n  ggobj = my_plot_comb,\n  width_svg = 6,\n  height_svg = 6*0.618,\n  options = list(\n    opts_tooltip(css = \"background-color:white; font-style:bold; color:green;\"),\n    opts_hover(css = \"fill: pink;\"),\n    opts_hover_inv(css = \"opacity:0.2;\")\n  )\n)\n\n\n\n\n\nInteractivity: Elements associated with a data_id (i.e CLASS) will be highlighted upon mouse over. At the same time, the tooltip will show the CLASS.\n\n\n2.1.8 Using onclick (click effect)\nonclick argument of ggiraph provides hotlink interactivity on the web.\n\nexam_data$onclick <- sprintf(\"window.open(\\\"%s%s\\\")\",\n\"https://www.moe.gov.sg/schoolfinder?journey=Primary%20school\",\nas.character(exam_data$ID))\n\nmy_plot <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n\n  geom_dotplot_interactive(\n    aes(onclick = onclick),\n    stackgroups = TRUE,\n    binwidth = 1,\n    method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(\n  ggobj = my_plot,\n  width_svg = 6,\n  height_svg = 6*0.618\n)\n\n\n\n\n\nInteractivity: Web document link with a data object will be displayed on the web browser upon mouse click. Note that click actions must be a string column in the dataset containing valid javascript instructions.\n\n\n2.1.9 Coordinated multiple views with ggiraph\nCoordinated multiple views methods is interactive in which when a data point of one of the dotplot is selected, the corresponding data point ID on the second data visualisation will be highlighted too.\nIn order to build a coordinated multiple views, the following programming strategy will be used:\n\nAppropriate interactive functions of ggiraph will be used to create the multiple views.\npatchwork function of patchwork package will be used inside girafe function to create the interactive coordinated multiple views.\n\n\np1 <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n\n  geom_dotplot_interactive(\n    aes(tooltip = ID,\n        data_id = ID),\n    stackgroups = TRUE,\n    binwidth = 1,\n    method = \"histodot\") +\n  coord_cartesian(xlim = c(0,100)) +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\np2 <- ggplot(data = exam_data,\n            aes(x = ENGLISH)) +\n  \n  geom_dotplot_interactive(\n    aes(tooltip = ID,\n        data_id = ID),\n    stackgroups = TRUE,\n    binwidth = 1,\n    method = \"histodot\") +\n  coord_cartesian(xlim = c(0,100)) +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(\n  code = print(p1 / p2),\n  width_svg = 6,\n  height_svg = 6,\n  options = list(\n    opts_hover(css = \"fill: blue;\"),\n    opts_hover_inv(css = \"opacity:0.2;\")    \n  )\n)\n\n\n\n\n\nThe data_id aesthetic is critical to link observations between plots and the tooltip aesthetic is optional but nice to have when mouse over a point.\n\n\n\n2.2 Using plotly method for interactive data visualization\n\nPlotly’s R graphing library create interactive web graphics from ggplot2 graphs and/or a custom interface to the (MIT-licensed) JavaScript library plotly.js inspired by the grammar of graphics.\nDifferent from other plotly platform, plot.R is free and open source.\n\nThere are two ways to create interactive graph by using plotly, they are:\n\nby using plot_ly(), and\nby using ggplotly()\n\n\n2.2.1 Using plot_ly\nCreating basic interactive scatterplot\n\nplot_ly(data = exam_data,\n        x = ~MATHS,\n        y = ~ENGLISH,\n        color = ~RACE)\n\n\n\n\n\nChanging the default color pallete to ColorBrewel colour palette\n\nplot_ly(data = exam_data, \n        x = ~MATHS, \n        y = ~ENGLISH, \n        color = ~RACE, \n        colors = \"Set1\")\n\n\n\n\n\nCustomising the color scheme manually\n\npal <- c(\"red\", \"purple\", \"blue\", \"green\")\n\nplot_ly(data = exam_data, \n        x = ~MATHS, \n        y = ~ENGLISH, \n        color = ~RACE, \n        colors = pal)\n\n\n\n\n\nCustomising tooltip\n\nplot_ly(data = exam_data, \n        x = ~MATHS, \n        y = ~ENGLISH,\n        text = ~paste(\"Student ID:\", ID,     \n                      \"<br>Class:\", CLASS),  \n        color = ~RACE, \n        colors = \"Set1\")\n\n\n\n\n\nWorking with layout. To learn more about layout, visit this link.\n\nplot_ly(data = exam_data, \n        x = ~MATHS, \n        y = ~ENGLISH,\n        text = ~paste(\"Student ID:\", ID,     \n                      \"<br>Class:\", CLASS),  \n        color = ~RACE, \n        colors = \"Set1\") |> \n  \n  layout(title = 'English Score versus Maths Score',\n         xaxis = list(range = c(0,100)),\n         yaxis = list(range = c(0,100)))\n\n\n\n\n\n\n\n2.2.2 Using ggplotly\nCreating basic interactive scatterplot. With ggplotly, we can use the original ggplot2 and add ggplotly at the end as extra line\n\np <- ggplot(data=exam_data, \n            aes(x = MATHS,\n                y = ENGLISH)) +\n  geom_point(dotsize = 1) +\n  coord_cartesian(xlim=c(0,100),\n                  ylim=c(0,100))\nggplotly(p) \n\n\n\n\n\nCreating Multiple Views using highlight_key and subplot of plotly package\n\nd <- highlight_key(exam_data)\n\np1 <- ggplot(data=d, \n              aes(x = MATHS,\n                  y = ENGLISH)) +\n  geom_point(size=1) +\n  coord_cartesian(xlim=c(0,100),\n                  ylim=c(0,100))\n\np2 <- ggplot(data=d, \n            aes(x = MATHS,\n                y = SCIENCE)) +\n  geom_point(size=1) +\n  coord_cartesian(xlim=c(0,100),\n                  ylim=c(0,100))\n\nsubplot(ggplotly(p1),\n        ggplotly(p2))\n\n\n\n\n\nClick on a data point of one of the scatterplot and see how the corresponding point on the other scatterplot is selected.\n\n\n\n2.3 Using crosstalk method for interactive data visualization\nCrosstalk is an add-on to the htmlwidgets package. It extends htmlwidgets with a set of classes, functions, and conventions for implementing cross-widget interactions (currently, linked brushing and filtering).\n\n2.3.1 Interactive Data Table: DT package\n\nA wrapper of the JavaScript Library DataTables\nData objects in R can be rendered as HTML tables using the JavaScript library ‘DataTables’ (typically via R Markdown or Shiny).\n\n\nDT::datatable(exam_data, class= \"compact\")\n\n\n\n\n\n\n\n\n2.3.2 Linked brushing using crosstalk method\nThings to learn from the code chunk:\n\nhighlight() is a function of plotly package. It sets a variety of options for brushing (i.e., highlighting) multiple plots. These options are primarily designed for linking multiple plotly graphs, and may not behave as expected when linking plotly to another htmlwidget package via crosstalk. In some cases, other htmlwidgets will respect these options, such as persistent selection in leaflet.\nbscols() is a helper function of crosstalk package. It makes it easy to put HTML elements side by side. It can be called directly from the console but is especially designed to work in an R Markdown document. Warning: This will bring in all of Bootstrap!.\n\n\nd <- highlight_key(exam_data)\n\np <- ggplot(data=d, \n              aes(x = MATHS,\n                  y = ENGLISH)) +\n  geom_point(size=1) +\n  coord_cartesian(xlim=c(0,100),\n                  ylim=c(0,100))\n\ngg <- highlight(ggplotly(p),\n                \"plotly_selected\")\n\ncrosstalk::bscols(gg,\n                  DT::datatable(d),\n                  widths = 5)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.4 Using gganimate method for creating animation\ngganimate extends the grammar of graphics as implemented by ggplot2 to include the description of animation. It does this by providing a range of new grammar classes that can be added to the plot object in order to customise how it should change with time.\n\ntransition_*() defines how the data should be spread out and how it relates to itself across time.\nview_*() defines how the positional scales should change along the animation.\nshadow_*() defines how data from other points in time should be presented in the given point in time.\nenter_*()/exit_*() defines how new data should appear and how old data should disappear during the course of the animation.\nease_aes() defines how different aesthetics should be eased during transitions.\n\nImport data from the Data worksheet from GlobalPopulation Excel workbook.\n\ncol <- c(\"Country\", \"Continent\")\nglobalPop <- read_xls(\"data/GlobalPopulation.xls\",\n                      sheet=\"Data\") %>%\n  mutate_each_(funs(factor(.)), col) %>%\n  mutate(Year = as.integer(Year))\n\nBasic ggplot function to create static bubble plot\n\nggplot(globalPop, aes(x = Old, y = Young, \n                      size = Population, \n                      colour = Country)) +\n  \n  geom_point(alpha = 0.7, \n             show.legend = FALSE) +\n  scale_colour_manual(values = country_colors) +\n  \n  scale_size(range = c(2, 12)) +\n  \n  labs(title = 'Year: {frame_time}', \n       x = '% Aged', \n       y = '% Young') \n\n\n\n\nBuilding animated bubble plot\n\nggplot(globalPop, aes(x = Old, y = Young, \n                      size = Population, \n                      colour = Country)) +\n  \n  geom_point(alpha = 0.7, \n             show.legend = FALSE) +\n  \n  scale_colour_manual(values = country_colors) +\n  \n  scale_size(range = c(2, 12)) +\n  \n  labs(title = 'Year: {frame_time}', \n       x = '% Aged', \n       y = '% Young') +\n  transition_time(Year) +       \n  ease_aes('linear')            \n\n\n\n\n\n\n2.5 Using packed_bar method for visualizing large data interatively\nPacked bar aims to support the need of visualising skewed data over hundreds of categories.\nImporting data\n\nGDP <- read_csv(\"data/GDP.csv\")\nWorldCountry <- read_csv(\"data/WorldCountry.csv\")\n\nData preparation\n\nGDP_selected <- GDP %>%\n  mutate(Values = as.numeric(`2020`)) %>%\n  select(1:3, Values) %>%\n  pivot_wider(names_from = `Series Name`,\n              values_from = `Values`) %>%\n  left_join(y=WorldCountry, by = c(\"Country Code\" = \"ISO-alpha3 Code\"))\n\nData preparation for packed bar\n\nGDP_selected_pb <- GDP %>%\n  mutate(GDP = as.numeric(`2020`)) %>%\n  filter(`Series Name` == \"GDP (current US$)\") %>%\n  select(1:2, GDP) %>%\n  na.omit()\n\nIn the code chunk below, plotly_packed_bar() of rPackedBar package is used to create an interactive packed bar. Refer to this Vignettes and the user guide to learn more about the package.\n\np = plotly_packed_bar(\n  input_data = GDP_selected_pb,\n  label_column = \"Country Name\",\n  value_column = \"GDP\",\n  number_rows = 10,\n  plot_title = \"Top 10 countries by GDP, 2020\",\n  xaxis_label = \"GDP (US$)\",\n  hover_label = \"GDP\",\n  min_label_width = 0.018,\n  color_bar_color = \"#00aced\",\n  label_color = \"white\")\nplotly::config(p, displayModeBar = FALSE)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04.html",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04.html",
    "title": "Hands-on Exercise 4: Fundamentals of Visual Analytics",
    "section": "",
    "text": "The code chunk below uses p_load() of pacman package to check if packages are installed in the computer. If they are, then they will be launched into R. The R packages installed are:\n\nggstatsplot is an extension of ggplot2 package for creating graphics with details from statistical tests included in the information-rich plots themselves.\n\n\npacman::p_load(ggstatsplot, tidyverse)\n\n\n\n\n\nexam_data <- read_csv(\"data/Exam_data.csv\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04.html#visual-statistical-analysis",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04.html#visual-statistical-analysis",
    "title": "Hands-on Exercise 4: Fundamentals of Visual Analytics",
    "section": "2. Visual Statistical Analysis",
    "text": "2. Visual Statistical Analysis\n\n2.1 One-sample test using gghistostats for\n\nset.seed(1234)\n\ngghistostats(\n  data = exam_data,\n  x = ENGLISH,\n  type = \"bayes\",\n  test.value = 60,\n  xlab = \"English scores\"\n)\n\n\n\n\nDefault information: - statistical details - Bayes Factor - sample sizes - distribution summary\nA Bayes factor is the ratio of the likelihood of one particular hypothesis to the likelihood of another. It can be interpreted as a measure of the strength of evidence in favor of one theory among two competing theories.\n\n\n2.2 Two-sample mean test using ggbetweenstats\n\nggbetweenstats(\n  data = exam_data,\n  x = GENDER,\n  y = MATHS,\n  type = \"np\",\n  messages = FALSE\n)\n\n\n\n\nDefault information: - statistical details - Bayes Factor - sample sizes - distribution summary\n\n\n2.3 Oneway ANOVA Test using ggbetweenstats\n\nggbetweenstats(\n  data = exam_data, \n  x = RACE, \n  y = ENGLISH, \n  type = \"p\", \n  mean.ci = TRUE, \n  pairwise.comparisons = TRUE,\n  #\"ns\" for only non-significant, \"s\" for only significant, \"all\" for everything\n  pairwise.display = \"s\",      \n  p.adjust.method = \"fdr\", \n  messages = FALSE \n  )\n\n\n\n\n\n\n2.4 Significant Test of Correlation using ggscatterstats\n\nggscatterstats(\n  data = exam_data,\n  x = MATHS,\n  y = ENGLISH,\n  marginal = FALSE\n)\n\n\n\n\n\n\n2.5 Significant Test of Association (Dependence) using ggbarstats\n\n#Binning Maths scores to 4-class variable\nexam1 <- exam_data |> \n  mutate(MATHS_bins =\n           cut(MATHS, \n               breaks = c(0, 60, 75, 85, 100)))\n\n\nggbarstats(\n  data = exam1,\n  x = MATHS_bins,\n  y = GENDER\n)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04.html#visualising-models",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04.html#visualising-models",
    "title": "Hands-on Exercise 4: Fundamentals of Visual Analytics",
    "section": "3. Visualising Models",
    "text": "3. Visualising Models\n\n3.1 Preparation\n\npacman::p_load(readxl, performance, parameters, see)\n\n\ncar_resale <- read_xls(\"data/ToyotaCorolla.xls\", \n                       \"data\")\n\n\n\n3.2 Multiple Regression Model using lm()\nCalibrate a multiple linear regression model by using lm() of Base Stats of R.\n\nmodel <- lm(Price ~ Age_08_04 + Mfg_Year + KM +\n              Weight + Guarantee_Period, data = car_resale)\nmodel\n\n\nCall:\nlm(formula = Price ~ Age_08_04 + Mfg_Year + KM + Weight + Guarantee_Period, \n    data = car_resale)\n\nCoefficients:\n     (Intercept)         Age_08_04          Mfg_Year                KM  \n      -2.637e+06        -1.409e+01         1.315e+03        -2.323e-02  \n          Weight  Guarantee_Period  \n       1.903e+01         2.770e+01  \n\n\n\n\n3.3 Checking for multicollinearity using check_collinearity()\n\ncheck_collinearity(model)\n\n# Check for Multicollinearity\n\nLow Correlation\n\n             Term   VIF     VIF 95% CI Increased SE Tolerance Tolerance 95% CI\n Guarantee_Period  1.04   [1.01, 1.17]         1.02      0.97     [0.86, 0.99]\n        Age_08_04 31.07 [28.08, 34.38]         5.57      0.03     [0.03, 0.04]\n         Mfg_Year 31.16 [28.16, 34.48]         5.58      0.03     [0.03, 0.04]\n\nHigh Correlation\n\n   Term  VIF   VIF 95% CI Increased SE Tolerance Tolerance 95% CI\n     KM 1.46 [1.37, 1.57]         1.21      0.68     [0.64, 0.73]\n Weight 1.41 [1.32, 1.51]         1.19      0.71     [0.66, 0.76]\n\n\n\n#plot the collinearity\nplot(check_collinearity(model))\n\n\n\n\nAge_08_04 and Mfg_Year are highly correlated. Remove Mfg_Year\n\n\n3.4 Checking for normality assumption using check_normality()\n\n#Remove Mfg_Year from model\nmodel1 <- lm(Price ~ Age_08_04 + KM + \n              Weight + Guarantee_Period, data = car_resale)\n\n\ncheck_n <- check_normality(model1)\nplot(check_n)\n\n\n\n\nThe analytical histogram above is specially designed for normality assumption test. When the residual histogram (in cyan colour) is not closed to the theoretical histogram (i.e in green), then we will reject the Null hypothesis and infer that the model residual failed to conform to normality assumption.\n\n\n3.5 Checking for homogeneity of variances using check_heteroscedasticity()\n\ncheck_h <- check_heteroscedasticity(model1)\nplot(check_h)\n\n\n\n\nThe analytical scatter plot is used to perform homogeneity of Variance assumption test. A constant variance distribution should be flat and horizontal and the data points should be scattered around the fit line. The chart above shows clear sign of heteroscedasticity.\n\n\n3.6 Complete check using check_model()\n\ncheck_model(model1)\n\n\n\n\n\n\n3.7 Visualising Regression Parameters\nUsing plot() and parameters()\n\nplot(parameters(model1))\n\n\n\n\nUsing ggcoefstats() of ggstatsplot package\n\nggcoefstats(model1, \n            output = \"plot\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04.html#visualising-uncertainty",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04.html#visualising-uncertainty",
    "title": "Hands-on Exercise 4: Fundamentals of Visual Analytics",
    "section": "4. Visualising Uncertainty",
    "text": "4. Visualising Uncertainty\n\n4.1 Preparation\n\npacman::p_load(tidyverse, plotly, crosstalk, DT, ggdist, gganimate)\n\n\n\n4.2 Visualizing uncertainty of point estimates using ggplot2\n\nA point estimate is a single number, such as a mean.\nUncertainty is expressed as standard error, confidence interval, or credible interval\nDon’t confuse the uncertainty of a point estimate with the variation in the sample\n\n\n#group by RACE and calculate mean, sd, and se of MATHS score\nmy_sum <- exam_data |> \n  group_by(RACE) |> \n  summarize(\n    n = n(),\n    mean = mean(MATHS),\n    sd = sd(MATHS)) |>\n  mutate(se = sd/sqrt(n-1))\nmy_sum$RACE  <- fct_reorder(my_sum$RACE, my_sum$mean, .desc = TRUE)\n\nshowing the tibble in html format\n\nknitr::kable(head(my_sum), format = 'html')\n\n\n\n \n  \n    RACE \n    n \n    mean \n    sd \n    se \n  \n \n\n  \n    Chinese \n    193 \n    76.50777 \n    15.69040 \n    1.132357 \n  \n  \n    Indian \n    12 \n    60.66667 \n    23.35237 \n    7.041005 \n  \n  \n    Malay \n    108 \n    57.44444 \n    21.13478 \n    2.043177 \n  \n  \n    Others \n    9 \n    69.66667 \n    10.72381 \n    3.791438 \n  \n\n\n\n\n\nUsing ggplot2 to reveal the standard error of mean maths score by race\n\nggplot(my_sum) +\n  \n  geom_errorbar(\n    aes(x = RACE,\n        ymin = mean - se,\n        ymax = mean + se),\n    width = 0.2,\n    colour = \"black\",\n    alpha = 0.9,\n    linewidth = 0.5) +\n  \n  geom_point(\n    aes(x = RACE,\n        y = mean),\n    stat = \"identity\",\n    colour = \"red\",\n    size = 1.5,\n    alpha = 1) +\n  \n  ggtitle(\"Standard error of mean\n          maths score by race\")\n\n\n\n\nUsing ggplot2 to reveal the 95% confidence interval of mean maths score by race\n\nggplot(my_sum) +\n  \n  geom_errorbar(\n    aes(x = RACE,\n        ymin = mean - 1.96*se,\n        ymax = mean + 1.96*se),\n    width = 0.2,\n    colour = \"black\",\n    alpha = 0.9,\n    linewidth = 0.5) +\n  \n  geom_point(\n    aes(x = RACE,\n        y = mean),\n    stat = \"identity\",\n    colour = \"red\",\n    size = 1.5,\n    alpha = 1) +\n  \n  ggtitle(\"95% confidence interval of mean maths score by race\")\n\n\n\n\nVisualizing the uncertainty of point estimates with interactive error bars\n\nd <- highlight_key(my_sum)\n\np <- ggplot(d) +\n  geom_errorbar(\n    aes(x = RACE,\n        ymin = mean - 2.58*se,\n        ymax = mean + 2.58*se),\n    width = 0.2,\n    colour = \"black\",\n    alpha = 0.9,\n    linewidth = 0.5) +\n  geom_point(\n    aes(x = RACE,\n        y = mean,\n        text = paste(\"Race:\", RACE,\n                     \"<br>N:\", n,\n                     \"<br>Avg. Scores:\", round(mean, digits = 2),\n                     \"<br>99% CI:[\", round(mean - 2.58*se, digits = 2), \", \", round(mean + 2.58*se, digits = 2), \"]\")),\n    stat = \"identity\",\n    colour = \"red\",\n    size = 1.5,\n    alpha = 1) +\n  \n  ggtitle(\"99% confidence interval of mean maths score by race\")\n\ngg <- highlight(ggplotly(p, tooltip = \"text\"),\n                \"plotly_selected\")\n\ndt <- DT::datatable(d,\n                    colnames = c(\"\",\"No. of pupils\", \"Avg Scores\", \"Std Dev\", \"Std Error\")) |> \n  formatRound(columns = c(\"mean\", \"sd\", \"se\"), digits = 2)\n\ncrosstalk::bscols(gg,\n                  dt,\n                  widths = 5)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.3 Visualizing uncertainty of point estimates using ggdist\n\nggdist is an R package that provides a flexible set of ggplot2 geoms and stats designed especially for visualising distributions and uncertainty.\nIt is designed for both frequentist and Bayesian uncertainty visualization, taking the view that uncertainty visualization can be unified through the perspective of distribution visualization:\n\nfor frequentist models, one visualises confidence distributions or bootstrap distributions (see vignette(“freq-uncertainty-vis”));\nfor Bayesian models, one visualises probability distributions (see the tidybayes package, which builds on top of ggdist).\n\n\nUsing stat_pointinterval() of ggdist to build a visual displaying distribution of math scores by race\n\nexam_data |> \n  ggplot(aes(x = RACE,\n             y = MATHS)) +\n  \n  #refer to point_interval argument in stat_pointinterval() help\n  stat_pointinterval(\n    .point = median,\n    .interval = qi     \n  ) +\n  \n  labs(\n    title = \"Visualising confidence intervals of median math score\",\n    subtitle = \"Median Point + Multiple-interval plot\"\n  )\n\n\n\n\nShowing 95% and 99% confidence interval with mean\n\nexam_data |> \n  ggplot(aes(x = RACE,\n             y = MATHS)) +\n  \n  #refer to point_interval argument in stat_pointinterval() help\n  stat_pointinterval(\n    .point = mean,\n    .interval = c(qi(0.05), qi(0.01))    \n  ) +\n  \n  labs(\n    title = \"Visualising confidence intervals of mean math score\",\n    subtitle = \"Mean Point + Multiple-interval plot\"\n  )\n\n\n\n\nUsing stat_gradientinterval() of ggdist to build a visual for displaying distribution of maths scores by race.\n\nexam_data |> \n  ggplot(aes(x = RACE,\n             y = MATHS)) +\n  \n  #refer to point_interval argument in stat_pointinterval() help\n  stat_gradientinterval(\n    .point = mean,\n    fill = \"skyblue\",\n    show.legend = TRUE\n  ) +\n  \n  labs(\n    title = \"Visualising confidence intervals of mean math score\",\n    subtitle = \"Gradient + interval plot\"\n  )"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex03/In-class_Ex03.html",
    "href": "In-class_Ex/In-class_Ex03/In-class_Ex03.html",
    "title": "In-class Exercise 3",
    "section": "",
    "text": "Install and loading R packages\nTwo packages will be installed and loaded. They are: tidyverse and ggiraph.\n\npacman::p_load(ggiraph, tidyverse)\n\n\n\nImporting data\n\nexam_data <- read_csv('data/Exam_data.csv')\n\n\n\nPlotting the graph\nUsing ggplot2 (non-interactive)\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_dotplot(dotsize = 0.5)\n\n\n\n\nUsing ggirafe (interactive)\n\np <- ggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_dotplot_interactive(\n    aes(tooltip = ID),\n    stackgroups = TRUE,\n    binwidth = 1,\n    method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(\n  ggobj = p,\n  width_svg = 6,\n  height_svg = 6*0.618\n)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Visual Analytics & Application Learning Journey",
    "section": "",
    "text": "“Numbers have an important story to tell. They rely on you to give them a clear and convincing voice”\n―Stephen Few\n\n\nWelcome to Visual Analytics & Application Learning Journey webpage.\nThis website hosted visual analytics journey while taking Visual Analytics Course (ISSS608) under Prof. Kam Tin Seong as part of Master of IT in Business (MITB) in Singapore Management University.\nThe exercises performed during my learning journey can be found in the navigation tab on the left.\nI hope you enjoy reading them!"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html",
    "title": "Take-home Exercise 1",
    "section": "",
    "text": "The original dataset was downloaded from Department of Statistics, Singapore, titled Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2022.\nThe file downloaded was respopagesextod2022.csv."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#step-by-step-description",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#step-by-step-description",
    "title": "Take-home Exercise 1",
    "section": "2. Step-by-Step Description",
    "text": "2. Step-by-Step Description\nThis section details the step-by-step procedure to create age-sex pyramid on Singapore population (2022) using Trellis display in Tableau.\n\n2.1 Loading and cleaning data\n\n\n\n\n\n\n\n\n\nStep\nScreenshot\n\n\n\n\n1\nLoad respopagesextod2022.csv file in Tableau Desktop\n\n\n\n2\nClick on the drop-down button on field “AG”, choose Create Calculation Field\n\n\n\n3\nName the new field “Age Group” and key in the formula as per screenshot. This will create new field to replace the “_” with space\n\n\n\n4\nRename field “PA” to “Planning Area”\n\n\n\n\n\n\n2.2 Creating calculated fields to make trellis chart\n\n\n\n\n\n\n\n\n\nStep\nScreenshot\n\n\n\n\n1\nCreate new worksheet and name it “Singapore Population Pyramid Trellis Chart (2022)”\n\n\n\n2\nClick on the drop-down button beside the Search are on the side bar, choose Create Calculation Field.\n\n\n\n3\nName the new field “Columns” and key in the formula as per screenshot. This is required to create the Trellis Chart arrangements\n\n\n\n4\nRight Click on newly created field “Columns” and click “Convert to Discrete”\n\n\n\n5\nRight Click on “Columns” field and choose Duplicate this time. Rename the duplicated field “Rows” and key in the formula as per screenshot. Convert the “Rows” field to discrete as well\n\n\n\n6\nRight Click on the “Sex” field, choose Create -> Calculation Field\n\n\n\n7\nName the new field it “Male Population” and key in the formula as per screenshot\n\n\n\n8\nRight Click on newly created field “Male Population” and choose Duplicate. Rename the duplicated field “Female Population” and key in the formula as per screenshot\n\n\n\n\n\n\n2.3 Creating trellis chart\n\n\n\n\n\n\n\n\n\nStep\nScreenshot\n\n\n\n\n1\nDrag “Columns”, “Male Population”, and “Female Population” to Columns.\nDrag “Rows” and “Age Group” to Rows\n\n\n\n2\nDrag “Planning Area” to Detail\n\n\n\n3\nRight click on “Male Population” axis and choose Edit Axis\n\n\n\n4\nClick on Reversed. This will reverse the “Male Population” axis to be in the middle (same as Female Population axis)\n\n\n\n5\nRight click on “Male Population” axis and choose Sort descending. This will ensure the top Age Group is “90 and over” as per Age-Sex pyramid\n\n\n\n6\nRight-click on “Columns” and choose Edit Table Calculation\n\n\n\n7\nIn the Table Calculation pop-up, choose Specific Dimension and check both “Planning Area” and “Age Group”. Drag “Planning Area” above “Age Group”\nChoose “Planning Area” on At the level option.\nRepeat step 6 and 7 for “Rows”\n\n\n\n8\nDrag “Planning Area” to filter and click OK\n\n\n\n9\nRight-click on “Planning Area” on Filter tab and choose Show Filter.\nThis will add the filter feature in the Worksheet\n\n\n\n10\nNavigate to Sum(Female Population) (red box) and click on the icon beside “Planning Area” and choose Label\nThis will add “Planning Area” as label on the right-side of the age-sex pyramid\n\n\n\n11\nChoose 9 Planning Areas randomly from the filter and choose Entire View from the Toolbar\nThis will show 9 chosen PAs and fit the entire view\n\n\n\n12\nRight-click on the “Columns” axis and uncheck Show Header to hide the “Columns” header\n\n\n\n13\nRight-click on the “Rows” axis and uncheck Show Header to hide the “Rows” header\n\n\n\n14\nDrag “Male Population” to SUM(Male Population) Color\nDrag “Female Population” to SUM(Female Population) Color\nThis will group the Sex by color in the dashboard\n\n\n\n15\nRight-click on the “Age Group” axis and choose Format\n\n\n\n16\nChoose Right alignment and reduce Font to 7. This will improve the readability of the Age Group axis labels\n\n\n\n17\nChoose the same axis range for both Male and Female Population to ensure balanced view\nIn this case, artificially fix this at 0 to 20,000\n\n\n\n\n\n\n2.4 Creating dynamic labels\n\n\n\n\n\n\n\n\n\nStep\nScreenshot\n\n\n\n\n1\nCreate new calculation field called “Max Population” and key in the formula as per screenshot\nThis calculates the max population of female for each pane, which will be used to determine label position\n\n\n\n2\nCreate new calculation field called “Label Position” and key in the formula as per screenshot\nThis ensures the label position is at the first index (top)\n\n\n\n3\nDrag “Label Position” to Columns, to the right of “SUM(Female Population)” and change the style as Line to display the point (red-circled) indicating the future label position\n\n\n\n4\nDrag “Planning Area” to Label of “Label Position” tab to display the “Planning Area” as label (red-boxes)\nClick on Size to reduce the point size to minimum. Click on Color to make it transparent (green-boxes). This will remove the point from display\n\n\n\n5\nThere will be sign showing “>162 nulls” values related to “Label Position”. This is because of the If-Then statement, which returns null to other indexes other than 1. Hide this warning as this is not relevant.\n\n\n\n6\nRight Click on “Label Position”, uncheck Show Header and choose Dual Axis\n\n\n\n7\nDrag “Male Population” to to Label of “SUM(Male Population)” tab to display the population values as label on the charts\nDo the same for “Female Population”\n\n\n\n8\nClick on the Label of “SUM(Male Population)” tab and format it to “Min/Max” and “Pane” to only highlight the min and max values per pane\nDo the same for “Female Population”\n\n\n\n9\nTo display values for special highlighted bar, right-click on individual bar, select Mark Label and tick Always Show\nThis will highlight relevant individual bars (refer to Section 3)\n\n\n\n\n\n\n2.5 Final touch-up to improve aesthetics and clarity\n\n\n\n\n\n\n\n\n\nStep\nScreenshot\n\n\n\n\n1\nDouble-click on the title to add the title\nSubtitle can be easily added by adding a new line with different font size\nThis will help users to understand the content and details of the dashboard\n\n\n\n2\nClick on Worksheet and click on Show Caption to show and edit the caption\n\n\n\n3\nDouble-click on the caption box (red-box) and edit the caption\nIn this case, we will add the source of the data. Format the text as shown on the right\n\n\n\n4\nWe will remove the x-axis title as there is already label to indicate Male and Female Population\nTo do this, double-click on the axis title and delete the Axis Title (red-box)\n\n\n\n\n\n\n2.6 Final Dashboard\nThe final dashboard is shown in Figure 1 below.\nThe default display shows age-sex (population) pyramid (June 2022) grouped by Singapore planning area in 3x3 trellis display. The user(s) will be able to select any planning areas of interest using the filter feature on the right without any restriction in number of choice. This gives them freedom to choose any planning areas of interest for study or comparison purposes.\nNote that the title and subtitle of the dashboard to highlight the purpose and the details of the visualization. The rationale in selecting the nine default planning areas will be explained in Section 3 below.\n\n\n\nFigure 1. Final dashboard display"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#discussion",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#discussion",
    "title": "Take-home Exercise 1",
    "section": "3. Discussion",
    "text": "3. Discussion\nThis section discusses the reasoning behind decisions made in creating the visualization and patterns revealed by the analysis.\n\n3.1 Unequal population distribution by planning area\nBy choosing all the filters (Figure 2), we can roughly group the planning areas (PAs) to three different categories:\n\nNon-residential PAs\nLower populated PAs\nHigher populated PAs\n\n\n\n\nFigure 2. Displaying all PAs reveals unequal population distribution across planning areas\n\n\nThe first category would fall under non-residential zones, which are mainly used for either commercial (Downtown), industrial (Changi), or natural zone (Central Water Catchment). Note this does not necessarily mean zero population, areas like Downtown have small residential populations, most likely represented by high-end luxury apartments.\nThe second category (i.e., Jurong East, Kallang, Novena) could be explained by mixed-area land-uses or simply due to smaller PA size, while the last category (i.e., Sengkang, Tampines, Yishun) is full-fledged residential area. Figure 3 below shows the three distinct PA categories.\n\n\n\nFigure 3. Three distinct PA categories revealed by the dashboard\n\n\nAs such, it makes sense to show the absolute population instead of percentage of PA population in the x-axis to showcase this unequal distribution. On top of that, we will exclude non-residential PAs from the analysis as they hold little significance.\n\n\n3.2 Different shapes of age-sex pyramids across PA\nFrom Figure 2 above, we can analyze not only the total population, but also the varying shapes of the pyramids across PAs. These pyramids have common features like thinning population at their pinnacles (eldest age-group) and thicker middle age-groups. However, there are notable differences as well.\nReferring to Figure 4 below, Bedok, Jurong West, and Ang Mo Kio pyramids are more rounded-shaped. Their highest age-group proportions lie around 50-70 years, with thinner population in other age-groups, indicating aging population.\nOn the other hand, Chua Chu Kang, Pasir Ris and Tampines still have high 50-70 years age-group population, but there is clear emerging young populations (20-35 years), making the pyramids look more like arrow-shaped. These trends are more prominent on the younger towns. Punggol is an extreme case with highly accentuated 35-45 and 5-10 years age groups.\nSome unique cases like Sembawang and Toa Payoh offer unexpectedly high 30-35 age-group, which almost looks like outliers, making the pyramids look jagged.\n\n\n\nFigure 4. Analyzing different shapes of age-sex pyramids\n\n\n\n\n3.3 Gender Ratio on each PA is relatively constant\nChoosing the 9 most populated PAs reveal relatively constant gender ratio on each PA, despite different shapes of the pyramids. This is accentuated in Figure 5 below.\n\n\n\nFigure 5. Nine most populated PA age-sex pyramids\n\n\nTo illustrate this, we can examine Jurong West and Punggol age-sex pyramids closely. Jurong West pyramids look rounded. Meanwhile, Punggol has a completely different arrow-shaped pyramid. Despite these differences, the proportion of male vs female population remains rather constant for different age groups (mirror-image across central axis). This observation is quite consistent across different PAs chosen.\nIt is noted, however, that at the higher age group, there tend to be more females than males. This is shown most clearly in Bedok (90 and over) with 1440 females vs 660 males. Combining this information with relatively uniform gender-ratio at the lower age group, this could be explained by higher life expectancy of females.\nRegardless, this trend was also observed in Figure 4 as well. Hence it was decided to select Figure 4 as the default PA filter as it highlights variations in pyramid shapes and total population."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html",
    "title": "Take-home Exercise 2",
    "section": "",
    "text": "This exercise aims to provide critique and improvements to age-sex (population) pyramid created by peer in Take-home Exercise 1 using Tableau. This will be done based on clarity and aesthetics. The original design will then be remade using data visualization design principles and best practices using ggplot2, its extensions, and tidyverse packages.\nThe original dataset was downloaded from Department of Statistics, Singapore, titled Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2022.\nThe file downloaded was respopagesextod2022.csv."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#data-visualization-critique",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#data-visualization-critique",
    "title": "Take-home Exercise 2",
    "section": "2. Data Visualization Critique",
    "text": "2. Data Visualization Critique\n\n2.1 Original Design\nFigure 1 below shows the original design of the Singapore population pyramid by Planning Area in June 2022.\n\n\n\nFigure 1. Original design of age-sex pyramid prepared by peer in Take Home Exercise 1 using Tableau\n\n\nThe link to the actual dashboard can be accessed here.\n\n\n\n\n\n2.2 Critique : Clarity and Aesthetics\n\nClarity\n\nWhile Tableau displays dynamic chart, the lack of x-axis in the plot makes it difficult to gauge the male and female population. This also potentially misleads audience as it wrongly presents different planning areas having comparable population size (i.e., population size of Downtown Core is much smaller than Tampines, but the length of the bars show that they are similar). This is because the scales of x-axis for different pyramids (in different planning areas) are inconsistent.\nLack of legend, making it difficult to determine which side represents Male or Female population. Note that traditionally, the Male population is on the left side of the pyramids, hence initially creating confusion between color and position without legend.\nThe title is descriptive, but not specific. For instance, it does not tell the audience which period was this from. Additionally, it does not tell the audience the context of the visualization (i.e., main highlight, story, etc). A well-worded title and subtitle should help here.\nThe original data age group binning (5 years) was kept. This is good as it keeps the resolution, grouping this to lower resolution (i.e., 10 years) might lead to detail loss. However, this leads to audience having to scroll down on each individual pyramid, making it difficult to observe patterns from quick glance.\nLack of references for audience to compare across different facets, having relevant data labels or reference line would improve readability.\nThe presence of grid lines without x-axis is meaningless as there is no reference point.\nThe order of the planning areas in the trellis chart is not meaningful.\nLack of caption to present the source of data.\n\n\n\nAesthetics\n\nGood color choices representing Male and Female population, making it easy to read.\nClear planning area labels for each population pyramid.\nUniform white background gives a clean look.\nSoft grid lines are not distracting.\nY-axis labels are not very easy to read due to presence of ‘_’."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#makeover-design",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#makeover-design",
    "title": "Take-home Exercise 2",
    "section": "3. Makeover Design",
    "text": "3. Makeover Design\n\n3.1 Proposed Sketch\nFrom the original visualization, it seems that the original author intends to contrast different population sizes and patterns across Singapore planning areas. This might be the reason for presenting low populated area like “Downtown Core” and highly populated area like “Tampines” together. One way to do this is to plot the absolute pyramids (based on actual population) of the original planning areas, ordered based on population sizes. Rough sketch of proposed design is shown below.\n\n\n\nFigure 2. Proposed sketch of the first plot\n\n\nAnother angle of visualizing age-sex pyramids is by plotting the proportion pyramids (based on proportion% of population). This will highlight the population patterns better without being influenced by the population size. With this, we could also add reference chart based on Singapore overall population proportion %. It is also important to have data labels highlighting the population of each planning area to still highlight the differences in population sizes.\n\n\n\nFigure 3. Proposed sketch of the second plot\n\n\n\n\n\n\n\n3.2 Data Preparation\nLaunch R packages and import data from csv using readr::read_csv().\nThe packages installed are tidyverse, cowplot and scales. While tidyverse contains all useful R packages used for cleaning data and plotting graph, cowplot is ggplot2 extension, providing professional-looking figure. scales helps to add comma and/or percentage for labels display. patchwork is used to combine the two visualizations. All packages can be found within CRAN.\n\n\nShow the code\n#Load packages\npacman::p_load(cowplot, scales, patchwork, tidyverse)\n\n#Import data\nsgpop <- read_csv(\"data/respopagesextod2022.csv\", show_col_types = FALSE)\n\n\n\nModifying the loaded data\n\nGroup the original data by planning area (PA), age group (AG), and gender (Sex) using dplyr::group_by() and dplyr::summarise(), deriving new variable called sum_pop, which is the sum of population grouped by the three variables mentioned. dplyr::ungroup() is used to avoid further complications.\nConvert Males population to negative to reverse the bar chart axis using dplyr::mutate() and ifelse.\nEliminate the ‘_’, ‘to’, ‘and over’ in age group (AG) using dplyr::mutate() and gsub().\nDerive variables min_pop and max_pop to determine the min and max male & female population values for each planning area (PA) across age group (AG). This will be used in conjunction with signal below for data labeling purpose.\nDerive new variables to calculate population proportion : sum of population by PA (sum_pop_pa), sum of population by age and sex (sum_pop_total), sum of total Singapore population (sum_pop_total_sg)\nUsing left_join() to create new clean tibble called sgpop_clean which will be used as final dataset for plotting\n\n\n\nShow the code\n#Data Cleaning\n#sgpop_group groups total population by PA, AG, and Sex to create base data for population pyramid\nsgpop_group <- sgpop |> \n  mutate(AG = gsub('_to_',' - ', AG),\n         AG = gsub('_and_over', '+', AG),\n         Pop = ifelse(Sex == \"Males\", Pop*(-1), Pop)) |>\n  group_by(PA, AG, Sex) |> \n  summarise(sum_pop = sum(Pop)) |> \n  ungroup()\n\n#sgpop_max_min creates summary parameters for max, min, and sum by grouping them on PA and Sex. AG is not included since we want to find total population across age group\nsgpop_max_min <- sgpop_group |> \n  group_by(PA, Sex) |> \n  summarise(max_pop = max(abs(sum_pop)),\n            min_pop = min(abs(sum_pop))) |> \n  ungroup()\n\n#sgpop_sum sums up the total population by planning area. This will be used to create proportion population per planning area\nsgpop_sum <- sgpop_group |> \n  group_by (PA) |> \n  summarise(sum_pop_pa = sum(abs(sum_pop))) |> \n  ungroup()\n\n#sgpop_total groups total population by AG and Sex to create base data for total Singapore population (across different PA)\nsgpop_total <- sgpop |>\n  mutate(AG = gsub('_to_',' - ', AG),\n         AG = gsub('_and_over', '+', AG),\n         Pop = ifelse(Sex == \"Males\", Pop*(-1), Pop)) |>\n  group_by(AG, Sex) |> \n  summarise(sum_pop_total = sum(Pop)) |> \n  ungroup()\n\n#sgpop_total_summ sums total Singapore population. This will be used to create Singapore proportion population for reference\nsgpop_total_summ <- sgpop_total |> \n  group_by (Sex) |> \n  summarise(sum_pop_total_ag = sum(sum_pop_total)) |> \n  mutate(sum_pop_total_sg = sum(abs(sum_pop_total_ag))) |> \n  ungroup()\n\n#joining multiple tibbles to create final sgpop_clean\nsgpop_draft1 = sgpop_group |> \n  left_join(sgpop_max_min, by = c('PA'='PA', 'Sex' = 'Sex')) \nsgpop_draft2 = sgpop_draft1 |> \n  left_join(sgpop_sum, by = c('PA' = 'PA'))\nsgpop_draft3 = sgpop_draft2 |> \n  left_join(sgpop_total, by = c('AG' = 'AG', 'Sex' = 'Sex'))\nsgpop_clean = sgpop_draft3 |> \n  left_join(sgpop_total_summ, by = 'Sex')\n\n\n\n\nFinal touch-up of the data sgpop_clean\n\nDerive new variables to calculate proportion of population for the second plot. There are two proportions:\n\nprop_pop which calculates proportion of population by age and sex in a given planning area\nprop_pop_total which calculates proportion of population by age and sex for the entire Singapore. This is required to create the reference chart\n\nDerive signal variable from min_pop and max_pop to help to position data labels in min/max values on the respective Males and Females charts. case_when is used to assign the values of -1, 1, 0 for max/min Males, max/min Females, and others respectively.\nVariable Sex and AG needs to be ordered to ensure that it appears as intended when plotting. As such forcats::fct_relevel() is used to order them manually.\n\n\n\nShow the code\n#adding new variables:\n#signal is used to display labels for min and max values in population pyramid\n#prop_pop is proportion population per planning area\n#prop_pop_total is proportion population of Singapore\nsgpop_clean <- sgpop_clean |> \n  mutate(signal = case_when((min_pop == abs(sum_pop) | max_pop == abs(sum_pop)) &\n                              Sex == \"Males\" ~ -1,\n                            (min_pop == abs(sum_pop) | max_pop == abs(sum_pop)) &\n                              Sex == \"Females\" ~ 1,\n                            TRUE~0),\n         prop_pop = round(sum_pop/sum_pop_pa*100, 1),\n         prop_pop_total = abs(round(sum_pop_total/sum_pop_total_sg*100, 1))\n         )\n\n#Order factors\nsgpop_clean$Sex <- fct_relevel(sgpop_clean$Sex, \"Males\")\nsgpop_clean$AG  <- fct_relevel(sgpop_clean$AG, \"0 - 4\", \"5 - 9\")\n\n\n\n\n\n\n\n\n3.3 Creating functions to plot the charts\nFunctions are used to plot the charts to give flexibility to user(s) to input their selected 9 planning areas, ordered by their preference. In this case, however, we will use the original 9 planning areas in the original design.\n\nThe multiple layers of the visualization function\n\nVariable PA needs to be ordered to ensure that it appears as intended when plotting the trellis chart. As such forcats::fct_reorder() is used to order them by population size (sum_pop_pa).\nggplot2::geom_col() to plot the pyramids. This is used instead of ggplot2::geom_bar() as we are plotting the values in the data instead of frequency of occurrence.\nAdding labels on min and max values is achieved using ggplot2::geom_text(). The variable signal is used here to determine whether the labels appear or not. The signal is multiplied by certain value to give certain distance from the end of the bar.\nOnly for second plot, ggplot2::geom_step() is used to create the dashed reference line representing Singapore overall population proportion (%).\nCustomise legend and color using ggplot2::scale_fill_manual().\nCustomise x-axis (population) scales using ggplot2::scale_y_continuous(). Note that we are not using ggplot2::scale_x_continuous() as we used ggplot2::coord_flip() before. Reason for this is because ggplot2::geom_step() is unable to plot categorical variables in y-axis.\nTo customise the title, subtitle, and caption, ggplot2::labs() is used.\nTrellis plot is created using ggplot2::facet_wrap(). Note that we are not using ggplot2::facet_grid() as we are creating the facets using one variable - PA.\nLabels for “Total Population” for each planning area is created using ggplot2::geom_label() to add nice border around the text.\ncowplot::theme_cowplot() is used to create more clean and professional look. Other theme adjustments utilise ggplot2::theme().\n\n\n\nCreating the two functions\n\nFunction plot_PA_pop is created to plot age-sex pyramids based on absolute population. This takes argument of vector of strings of the planning areas.\n\n\n\nShow the code\n#Setting the axis range and limits\npop_range_breaks = seq(-15000,15000,7500)   \npop_range_limits = c(-16000, 16000)                   \n\n#Create function to plot based on absolute population\nplot_PA_pop <- function(planning_area) {\n  sgpop_clean$PA  <- fct_reorder(sgpop_clean$PA, sgpop_clean$sum_pop_pa)\n  ggplot(data = sgpop_clean |> \n           filter(PA %in% planning_area)) +\n    \n    #creating bar charts\n    geom_col(aes(x = AG,\n                 y = sum_pop, \n                 fill = Sex)) +\n    \n    #adding labels on min and max values\n    geom_text(\n      data = sgpop_clean |> filter(PA %in% planning_area & signal != 0),\n      aes(x = AG,\n          y = sum_pop+signal*2500,\n          label = comma(abs(sum_pop))\n          )) +\n    \n    coord_flip() +\n    \n    #adding legends and customize colors\n    scale_fill_manual(values = c(\"steelblue\", \"#f6546a\"),\n                      labels = c(\"Male\", \"Female\"),\n                      name = NULL) +\n    \n    #scale axis\n    scale_y_continuous(\"Population\",\n                       limits = pop_range_limits,\n                       breaks = pop_range_breaks,\n                       labels = function(x){paste0(abs(x/1000),'K')}) +\n    \n    #adding title, subtitle, and caption\n    labs(title = \"Population sizes and patterns can differ drastically across Singapore planning areas\",\n         subtitle = paste0(\"Singapore age-sex pyramids (absolute population) by Planning Area, June 2022\\nTotal Singapore Residents Population : \",comma(sgpop_clean$sum_pop_total_sg)),\n         caption = \"Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2022 from Department of Statistics, Singapore\") +\n    \n    #create trellis plot and PA population label\n    facet_wrap(~PA) +\n    geom_label(\n      x = 18,\n      y = 9000,\n      aes(label = paste(\"Total Pop\", comma(sum_pop_pa), sep = \"\\n\")),\n      hjust = \"left\") +\n    \n    #setting theme and aesthetics\n    cowplot::theme_cowplot() +\n    theme(axis.title.x = element_text(vjust = 0.5),\n          axis.title.y = element_blank(),\n          axis.ticks.y = element_blank(),\n          panel.grid.major.x = element_line(color = \"grey90\", linetype = \"solid\"),\n          panel.grid.major.y = element_line(color = \"grey90\", linetype = \"solid\"),\n          legend.position = 'top',\n          legend.justification = 'center',\n          panel.border = element_rect(color = \"grey60\", linetype = \"solid\", linewidth = 0.5),\n          panel.spacing.x = unit(0,\"line\"),\n          panel.spacing.y = unit(0,\"line\"))\n}\n\n\n\nFunction is created to plot age-sex pyramids based on population proportion (%). This also takes argument of vector of strings of the planning areas. However this chart also shows the reference chart based on Singapore overall population proportion %. There are two versions of the reference charts created:\n\n\n\nRepresenting Singapore population proportion % with reference-step line (plot_PA_prop)\n\n\n\nShow the code\n#Setting the axis range and limits\npop_range_breaks_prop = seq(-8,8,4)                     \npop_range_limits_prop = c(-9, 9)   \n\n#Create function to plot based on population proportion \nplot_PA_prop <- function(planning_area) {\n  sgpop_clean$PA  <- fct_reorder(sgpop_clean$PA, sgpop_clean$sum_pop_pa)\n  ggplot(data = sgpop_clean |> filter(PA %in% planning_area),\n         aes(group = 1)) +\n    \n    #creating bar charts\n    geom_col(aes(x = AG,\n                 y = prop_pop, \n                 fill = Sex)) +\n    \n    #adding labels on min and max values\n    geom_text(\n      data = sgpop_clean |> filter(PA %in% planning_area & signal != 0),\n      aes(x = AG,\n          y = prop_pop+signal*1.5,\n          label = paste0(abs(prop_pop),'%')\n          )) +\n    \n    #adding reference step chart\n    geom_step(data = sgpop_clean |> filter(PA %in% planning_area & Sex == \"Males\"),\n      aes(x = AG,\n          y = -prop_pop_total,\n          color =\"singpopline\"),\n      linetype = \"dashed\",\n      linewidth = 0.6) +\n    geom_step(data = sgpop_clean |> filter(PA %in% planning_area & Sex == \"Females\"),\n      aes(x = AG,\n          y = prop_pop_total,\n          color =\"singpopline\"),\n      linetype = \"dashed\",\n      linewidth = 0.6) +\n    \n    coord_flip() +\n    \n    #adding legends and customize colors\n    scale_fill_manual(values = c(\"steelblue\", \"#f6546a\"),\n                      labels = c(\"Male%\", \"Female%\"),\n                      name = NULL) +\n    \n    scale_color_manual(values = (\"singpopline\" = \"black\"),\n                       labels = (\"singpopline\" = \"Singapore Population%\"),\n                       name = NULL) +\n    \n    #scale axis\n    scale_y_continuous(\"Population Proportion\",\n                       limits = pop_range_limits_prop,\n                       breaks = pop_range_breaks_prop,\n                       labels = function(x){paste0(abs(x),'%')}) +\n    \n    #adding title, subtitle, and caption\n    labs(title = \"Different demographic patterns are revealed when population proportion (%) is used in the pyramid\",\n         subtitle = paste0(\"Singapore age-sex pyramids (proportion population) by Planning Area, June 2022\\nTotal Singapore Residents Population : \",comma(sgpop_clean$sum_pop_total_sg),\"\\nReference step chart (dashed line) represents Singapore overall population proportion (%)\"),\n         caption = \"Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2022 from Department of Statistics, Singapore\") +\n    \n    #create trellis plot and PA population label\n    facet_wrap(~PA) +\n    geom_label(\n      x = 18,\n      y = 5,\n      aes(label = paste(\"Total Pop\", comma(sum_pop_pa), sep = \"\\n\")),\n      hjust = \"left\") +\n        \n    #setting theme and aesthetics\n    cowplot::theme_cowplot() +\n    theme(axis.title.x = element_text(vjust = 0.5),\n          axis.title.y = element_blank(),\n          axis.ticks.y = element_blank(),\n          panel.grid.major.x = element_line(color = \"grey90\", linetype = \"solid\"),\n          panel.grid.major.y = element_line(color = \"grey90\", linetype = \"solid\"),\n          legend.position = 'top',\n          legend.justification = 'center',\n          panel.border = element_rect(color = \"grey60\", linetype = \"solid\", linewidth = 0.5),\n          panel.spacing.x = unit(0,\"line\"),\n          panel.spacing.y = unit(0,\"line\")) \n}\n\n\n\nRepresenting Singapore population proportion % with reference bar chart (plot_PA_prop_bar)\n\n\n\nShow the code\n#Setting the axis range and limits\npop_range_breaks_prop = seq(-8,8,4)                     \npop_range_limits_prop = c(-9, 9)\n\n#Create function to plot based on population proportion \nplot_PA_prop_bar <- function(planning_area) {\n  sgpop_clean$PA  <- fct_reorder(sgpop_clean$PA, sgpop_clean$sum_pop_pa)\n  ggplot(data = sgpop_clean |> filter(PA %in% planning_area),\n         aes(group = 1)) +\n    \n    #creating bar charts\n    geom_col(aes(x = AG,\n                 y = prop_pop, \n                 fill = Sex)) +\n    \n    #adding labels on min and max values\n    geom_text(\n      data = sgpop_clean |> filter(PA %in% planning_area & signal != 0),\n      aes(x = AG,\n          y = prop_pop+signal*1.5,\n          label = paste0(abs(prop_pop),'%')\n          )) +\n    \n    #adding reference bar chart\n    geom_col(data = sgpop_clean |> filter(PA %in% planning_area & Sex == \"Males\"),\n      aes(x = AG,\n          y = -prop_pop_total,\n          fill =\"singpop\"),\n      alpha = 0.6) +\n    geom_col(data = sgpop_clean |> filter(PA %in% planning_area & Sex == \"Females\"),\n      aes(x = AG,\n          y = prop_pop_total,\n          fill =\"singpop\"),\n      alpha = 0.6) +\n    \n    coord_flip() +\n    \n    #adding legends and customize colors\n    scale_fill_manual(values = c(\"Males\" = \"steelblue\", \"Females\" = \"#f6546a\", \"singpop\" = \"grey60\"),\n                      breaks = c(\"singpop\", \"Males\", \"Females\"),\n                      labels = c(\"Males\" = \"Male%\", \"Females\" = \"Female%\", \"singpop\" = \"Singapore Population%\"),\n                      name = NULL) +\n    \n    #scale axis\n    scale_y_continuous(\"Population Proportion\",\n                       limits = pop_range_limits_prop,\n                       breaks = pop_range_breaks_prop,\n                       labels = function(x){paste0(abs(x),'%')}) +\n    \n    #adding title, subtitle, and caption\n    labs(title = \"Different demographic patterns are revealed when population proportion (%) is used in the pyramid\",\n         subtitle = paste0(\"Singapore age-sex pyramids (proportion population) by Planning Area, June 2022\\nTotal Singapore Residents Population : \",comma(sgpop_clean$sum_pop_total_sg),\"\\nReference bar chart (transparent grey) represents Singapore overall population proportion (%)\"),\n         caption = \"Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2022 from Department of Statistics, Singapore\") +\n    \n    #create trellis plot and PA population label\n    facet_wrap(~PA) +\n    geom_label(\n      x = 18,\n      y = 5,\n      aes(label = paste(\"Total Pop\", comma(sum_pop_pa), sep = \"\\n\")),\n      hjust = \"left\") +\n        \n    #setting theme and aesthetics\n    cowplot::theme_cowplot() +\n    theme(axis.title.x = element_text(vjust = 0.5),\n          axis.title.y = element_blank(),\n          axis.ticks.y = element_blank(),\n          panel.grid.major.x = element_line(color = \"grey90\", linetype = \"solid\"),\n          panel.grid.major.y = element_line(color = \"grey90\", linetype = \"solid\"),\n          legend.position = 'top',\n          legend.justification = 'center',\n          panel.border = element_rect(color = \"grey60\", linetype = \"solid\", linewidth = 0.5),\n          panel.spacing.x = unit(0,\"line\"),\n          panel.spacing.y = unit(0,\"line\")) \n}\n\n\n\n\n\n\n\n\n3.4 Plotting the makeover charts\nAs mentioned above, the first plot contrasts different population sizes and patterns across Singapore planning areas. As such absolute age-sex pyramids are plotted in 3x3 trellis chart. The reason for choosing 3x3 is to fit the display in one screen webpage (using quarto). Having 9x1 or 1x9 will either require audience to scroll or squeeze the pyramids too closely together.\n\n\nShow the code\n#Calling the function to plot absolute population pyramid by the nine planning areas selected by peer\np1 <- plot_PA_pop(c(\"Changi\", \"Downtown Core\", \"Newton\", \"Bukit Timah\",\"Clementi\", \"Sembawang\", \"Serangoon\", \"Hougang\", \"Tampines\"))\np1\n\n\n\n\n\nThe second plot presents an alternative angle to the same planning areas, highlighting the population patterns better without being influenced by the population size. Reference chart based on Singapore overall population proportion % is added to allow audience to see how different planning areas population patterns differ from national proportion. Note that the reference chart is only possible to be added in the second plot as putting this in first plot will overshadow individual planning area pyramids. This is due to sheer size of Singapore population relative to each planning area. The two versions of the second plot is presented below.\n\nRepresenting Singapore population proportion % with reference-step line\n\n\n\nShow the code\n#Calling the function to plot proportion population pyramid by the nine planning areas selected by peer\np2a <- plot_PA_prop(c(\"Changi\", \"Downtown Core\", \"Newton\", \"Bukit Timah\",\"Clementi\", \"Sembawang\", \"Serangoon\", \"Hougang\", \"Tampines\"))\np2a\n\n\n\n\n\n\nRepresenting Singapore population proportion % with reference bar chart\n\n\n\nShow the code\n#Calling the function to plot proportion population pyramid by the nine planning areas selected by peer\np2b <- plot_PA_prop_bar(c(\"Changi\", \"Downtown Core\", \"Newton\", \"Bukit Timah\",\"Clementi\", \"Sembawang\", \"Serangoon\", \"Hougang\", \"Tampines\"))\np2b\n\n\n\n\n\nNote that it is quite difficult to see the reference bar chart, especially for certain planning areas like Clementi or Hougang, in which there is large overlap with overall Singapore Population pyramid. As such it might make sense to use the step chart instead as the final visualization.\n\nFinal Visualization\nThe final visualization is created using patchwork to stitch the two plots together. This will put the two trellis charts side-by-side, showcasing the different angles brought about by the two plots.\n\n\n\n\n\n\n\n\nShow the code\n#Calling the function to plot proportion population pyramid by the nine planning areas selected by peer\nfinal_plot <- p1 + p2a\nfinal_plot + plot_annotation(\n  title = 'Population sizes differ drastically across Singapore planning areas, however its pattern differences are further revealed with proportion pyramid (%)',\n  subtitle = paste0(\"Singapore age-sex pyramids by Planning Area, June 2022\\nTotal Singapore Residents Population : \",comma(sgpop_clean$sum_pop_total_sg),\"\\nReference step chart (dashed line) on Plot 2 represents Singapore overall population proportion (%)\"),\n  caption = \"Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2022 from Department of Statistics, Singapore\",\n  theme = theme(plot.title = element_text(face = \"bold\", size = 24),\n                plot.subtitle = element_text(size = 18))\n)\n\n\n\n\n\n\n\nClarity Improvements\n\nConsistent scale of x-axis allows fair comparisons of population size and patterns across different planning areas. This is especially important since the population sizes for different planning areas differ greatly.\nAs ggplot2 plots a static chart, having grid lines are important for audience for referencing. In this case, both y and x-axis grid lines are kept to ease readability, allowing audience to refer even the furthest pyramid from the axis (top right pyramid).\nLegend is provided and the “Male” bar chart is put to the left, allowing faster recognition.\nThe title describes the context of the visualization, which is to contrast population sizes and patterns across different planning areas. Subtitle also provides factual clarity of the plots with total population displayed as reference.\nBy adjusting the plot height, the solutions presented still keep the original resolution (5-year), without audience having to scroll down on each individual facet. This eases comparison among all pyramids in one view.\nOnly data labels for min and max population across age groups for each planning areas are provided. This gives reference for audience without overwhelming them with too much text labels.\nAnnotations on each facets highlighting the total population for different planning areas gives an anchor point for audience, further spotlighting the context (different population sizes) of visualization.\nReference chart of second plot adds another dimension of comparison for audience.\nThe planning area is ordered by population sizes, allowing audience to contrast the pyramid sizes per row (for the first plot)\nCaption is provided to present the source of data.\n\n\n\nAesthetics Improvements\n\nSoft solid grid lines are not distracting.\nReference chart is in step chart to mimic the shape of population pyramids. It is also dashed to better distinguish from the grid lines. As discussed above, this offers better overall visualization than the transparent bar charts.\nTick-marks for y-axis (age group) are removed as they are superfluous for categorical variables.\nThe y-axis label “Age Group” is removed as the subtitle already describes it as age-sex pyramids."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#learning-points",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#learning-points",
    "title": "Take-home Exercise 2",
    "section": "4. Learning Points",
    "text": "4. Learning Points\nThis exercise resembles the first assignment closely, using the same data to visualize the trellis chart of age-sex pyramids. However it requires the students to use ggplot2, its extensions, and tidyverse packages instead of Tableau. It also adds another dimension of critique and makeover of peer works which helps to embed best practices in data visualization. The key takeaways are:\n\nIt is important to start by questioning the purpose and intent of the visualization. By understanding this, one can start experimenting and designing the apt visualization from different dimensions. One example would be the second plot produced in this exercise, looking at the age-sex pyramid from the population proportion (%) rather than absolute values.\nThere is no best visualization as there might be some trade-offs between clarity and aesthetics. Adding horizontal (y-axis) grid lines in this chart presented me with a dilemma as it reduces aesthetics (by cluttering the plots), but adds additional clarity, assisting the audience to refer to the age group. This is particularly important for static visualization like this.\nLearning to critique other peer’s works help to identify pain points, to understand best practices, and to awaken new ideas that were not surfaced during Take-home Exercise 1."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04.html#building-funnel-plot-with-r",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04.html#building-funnel-plot-with-r",
    "title": "Hands-on Exercise 4: Fundamentals of Visual Analytics",
    "section": "5. Building Funnel Plot with R",
    "text": "5. Building Funnel Plot with R\nFunnel plot is a specially designed data visualisation for conducting unbiased comparison between outlets, stores or business entities.\n\n5.1 Preparation\nFive R packages will be used. They are:\n\nreadr for importing csv into R.\nFunnelPlotR for creating funnel plot.\nggplot2 for creating funnel plot manually.\nknitr for building static html table.\nplotly for creating interactive funnel plot.\n\n\npacman::p_load(tidyverse, FunnelPlotR, plotly, knitr)\n\nImporting data\n\ncovid19 <- read_csv(\"data/COVID-19_DKI_Jakarta.csv\") |> \n  mutate_if(is.character, as.factor)\n\nhead(covid19)\n\n# A tibble: 6 × 7\n  `Sub-district ID` City            District       Sub-d…¹ Posit…² Recov…³ Death\n              <dbl> <fct>           <fct>          <fct>     <dbl>   <dbl> <dbl>\n1        3172051003 JAKARTA UTARA   PADEMANGAN     ANCOL      1776    1691    26\n2        3173041007 JAKARTA BARAT   TAMBORA        ANGKE      1783    1720    29\n3        3175041005 JAKARTA TIMUR   KRAMAT JATI    BALE K…    2049    1964    31\n4        3175031003 JAKARTA TIMUR   JATINEGARA     BALI M…     827     797    13\n5        3175101006 JAKARTA TIMUR   CIPAYUNG       BAMBU …    2866    2792    27\n6        3174031002 JAKARTA SELATAN MAMPANG PRAPA… BANGKA     1828    1757    26\n# … with abbreviated variable names ¹​`Sub-district`, ²​Positive, ³​Recovered\n\n\n\n\n5.2 FunnelPlotR methods\nFunnelPlotR package uses ggplot to generate funnel plots. It requires a numerator (events of interest), denominator (population to be considered) and group. The key arguments selected for customisation are:\n\nlimit: plot limits (95 or 99).\nlabel_outliers: to label outliers (true or false).\nPoisson_limits: to add Poisson limits to the plot.\nOD_adjust: to add overdispersed limits to the plot.\nxrange and yrange: to specify the range to display for axes, acts like a zoom function.\nOther aesthetic components such as graph title, axis labels etc.\n\nBasic plot\n\nfunnel_plot(\n  numerator = covid19$Death,\n  denominator = covid19$Positive,\n  #group determines the level of points to e plotted\n  group = covid19$`Sub-district`,\n  #change from defaut 'SR' to 'PR'\n  data_type = \"PR\",\n  x_range = c(0, 6500),\n  y_range = c(0, 0.05),\n  #label = NA removes the default label outliers feature\n  label = NA,\n  title = \"Cumulative COVID-19 Fatality Rate by Cumulative Total Number of COVID-19 Positive Cases\",\n  x_label = \"Cumulative COVID-19 Positive Cases\",\n  y_label = \"Cumulative Fatality Rate\" \n  )\n\n\n\n\nA funnel plot object with 267 points of which 7 are outliers. \nPlot is adjusted for overdispersion. \n\n\n\n\n5.3 ggplot2 method\nData preparation\n\ndf <- covid19 |> \n  mutate(rate = Death/Positive) |> \n  mutate(rate.se = sqrt((rate*(1-rate)) / (Positive))) |> \n  filter(rate > 0)\n\nNext, the fit.mean is computed by using the code chunk below.\n\nfit.mean <- weighted.mean(df$rate, 1/df$rate.se^2)\n\nCalculate the lower an upper limits for 95% and 99% CI\n\nnumber.seq <- seq(1, max(df$Positive), 1)\nnumber.ll95 <- fit.mean - 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ul95 <- fit.mean + 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ll999 <- fit.mean - 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ul999 <- fit.mean + 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \ndfCI <- data.frame(number.ll95, number.ul95, number.ll999, number.ul999, number.seq, fit.mean)\n\nPlotting static funnel plot\n\np <- ggplot(df, aes(x = Positive, y = rate)) +\n  geom_point(aes(label=`Sub-district`), \n             alpha=0.4) +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ll95), \n            linewidth = 0.4, \n            colour = \"grey40\", \n            linetype = \"dashed\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ul95), \n            linewidth = 0.4, \n            colour = \"grey40\", \n            linetype = \"dashed\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ll999), \n            linewidth = 0.4, \n            colour = \"grey40\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ul999), \n            linewidth = 0.4, \n            colour = \"grey40\") +\n  geom_hline(data = dfCI, \n             aes(yintercept = fit.mean), \n             linewidth = 0.4, \n             colour = \"grey40\") +\n  coord_cartesian(ylim=c(0,0.05)) +\n  annotate(\"text\", x = 1, y = -0.13, label = \"95%\", size = 3, colour = \"grey40\") + \n  annotate(\"text\", x = 4.5, y = -0.18, label = \"99%\", size = 3, colour = \"grey40\") + \n  ggtitle(\"Cumulative Fatality Rate by Cumulative Number of COVID-19 Cases\") +\n  xlab(\"Cumulative Number of COVID-19 Cases\") + \n  ylab(\"Cumulative Fatality Rate\") +\n  theme_light() +\n  theme(plot.title = element_text(size=12),\n        legend.position = c(0.91,0.85), \n        legend.title = element_text(size=7),\n        legend.text = element_text(size=7),\n        legend.background = element_rect(colour = \"grey60\", linetype = \"dotted\"),\n        legend.key.height = unit(0.3, \"cm\"))\np\n\n\n\n\nPass this to ggplotly\n\nfp_ggplotly <- ggplotly(p,\n  tooltip = c(\"label\", \n              \"x\", \n              \"y\"))\nfp_ggplotly"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex04/In-class_Ex04.html",
    "href": "In-class_Ex/In-class_Ex04/In-class_Ex04.html",
    "title": "In-class Exercise 4",
    "section": "",
    "text": "1. Install and loading R packages\nPackages will be installed and loaded. Note that performance, parameters, see are under easystats\n\npacman::p_load(plotly, DT, patchwork, ggstatsplot, readxl, performance, parameters, see, gtsummary, tidyverse)\n\n\n\n2. Importing Data\n\nexam_data <- read_csv(\"data/Exam_data.csv\")\n\n\ncar_resale <- read_xls(\"data/ToyotaCorolla.xls\", \n                       \"data\")\n\n\n\n3. Interactivity in plotting\n\nPlotting with native plot_ly()\n\nplot_ly(data = exam_data,\n        x = ~ENGLISH,\n        y = ~MATHS,\n        color = ~RACE)\n\n\n\n\n\n\n\nPlotting with ggplot2 and wrapped with ggplotly()\nNote that only native ggplot2 can be used\n\np <- ggplot(data=exam_data, \n            aes(x = MATHS,\n                y = ENGLISH,\n                color = RACE)) +\n  geom_point(size = 1) +\n  coord_cartesian(xlim=c(0,100),\n                  ylim=c(0,100))\nggplotly(p) \n\n\n\n\n\n\n\n\n4. Visual statistical plotting\n\nTwo-sample mean testing\n\nggbetweenstats(\n  data = exam_data,\n  x = GENDER,\n  y = MATHS,\n  #\"p\" is parametric test while \"np\" is non-parametric test\n  type = \"p\",\n  messages = FALSE\n)\n\n\n\n\nBayesian test (bottom-right) is only displayed for parametric test (normality assumption) as they are comparing the mean. Note that Welch test is used as it does not assume equal variance.\n\n\nScatterplot testing\n\nggscatterstats(\n  data = exam_data,\n  x = MATHS,\n  y = ENGLISH,\n  #the default for marginal is TRUE which will show the marginal plots\n  marginal = TRUE\n)\n\n\n\n\n\n\n\n5. Model visualization\n\nBuilding least-square multiple regression model\nlm() is base R model to build least-square multiple regression model\n\nmodel <- lm(Price ~ Age_08_04 + Mfg_Year + KM +\n              Weight + Guarantee_Period, data = car_resale)\nmodel\n\n\nCall:\nlm(formula = Price ~ Age_08_04 + Mfg_Year + KM + Weight + Guarantee_Period, \n    data = car_resale)\n\nCoefficients:\n     (Intercept)         Age_08_04          Mfg_Year                KM  \n      -2.637e+06        -1.409e+01         1.315e+03        -2.323e-02  \n          Weight  Guarantee_Period  \n       1.903e+01         2.770e+01  \n\n\nUse gtsummary to summarize data sets, regression models, and more, using sensible defaults with highly customisable capabilities.\n\n\n\n\n\nDiagnostic test : Check for multi-collinearity\nVisualizing multi-collinearity of the model.\nNote that check_c is a dataframe.\n\ncheck_c <- check_collinearity(model)\nplot(check_c)\n\n\n\n\n\n\nDiagnostic test : Check for normality assumption\n\n#Remove Mfg_Year from model due to high collinearity\nmodel1 <- lm(Price ~ Age_08_04 + KM + \n              Weight + Guarantee_Period, data = car_resale)\nmodel1\n\n\nCall:\nlm(formula = Price ~ Age_08_04 + KM + Weight + Guarantee_Period, \n    data = car_resale)\n\nCoefficients:\n     (Intercept)         Age_08_04                KM            Weight  \n      -2.186e+03        -1.195e+02        -2.406e-02         1.972e+01  \nGuarantee_Period  \n       2.682e+01  \n\n\nVisualizing normality assumption of the model.\nNote that check_n is a dataframe.\n\ncheck_n <- check_normality(model1)\nplot(check_n)\n\n\n\n\n\n\nDiagnostic test : Check for variance homogeneity\nNote that check_h is a dataframe.\n\ncheck_h <- check_heteroscedasticity(model1)\nplot(check_h)\n\n\n\n\n\n\nDiagnostic test : Check for everything\n\ncheck_model(model1)\n\n\n\n\n\n\nVisualizing regression parameters\n\nplot(parameters(model1))\n\n\n\n\n\nggcoefstats(model1, \n            output = \"plot\")\n\n\n\n\n\n\n\n6. Visualization of uncertainty\nData preparation\n\n#group by RACE and calculate mean, sd, and se of MATHS score\nmy_sum <- exam_data |> \n  group_by(RACE) |> \n  summarize(\n    n = n(),\n    mean = mean(MATHS),\n    sd = sd(MATHS)) |>\n  mutate(se = sd/sqrt(n-1))\n\nPlotting using ggplot2\n\nggplot(my_sum) +\n  \n  geom_errorbar(\n    aes(x = RACE,\n        ymin = mean - se,\n        ymax = mean + se),\n    width = 0.2,\n    colour = \"black\",\n    alpha = 0.9,\n    linewidth = 0.5) +\n  \n  geom_point(\n    aes(x = RACE,\n        y = mean),\n    stat = \"identity\",\n    colour = \"red\",\n    size = 1.5,\n    alpha = 1) +\n  \n  ggtitle(\"Standard error of mean\n          maths score by race\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html",
    "title": "Take-home Exercise 3",
    "section": "",
    "text": "This exercise aims to uncover the salient patterns of the resale prices of public housing property by residential towns and estates in Singapore using appropriate analytical visualisation techniques. The visualization is designed using ggplot2, its extensions, and tidyverse packages.\nThe original dataset was downloaded from Data.gov.sg titled Resale flat princes based on registration date from Jan-2017 onwards.\nThe file downloaded was resale-flat-prices-based-on-registration-date-from-jan-2017-onwards.csv\nThe focus of the study is on 3-ROOM, 4-ROOM and 5-ROOM types for 2022 period."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#data-preparation",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#data-preparation",
    "title": "Take-home Exercise 3",
    "section": "2. Data Preparation",
    "text": "2. Data Preparation\n\n2.1 Install R packages and import dataset\nThe code chunk below uses pacman::p_load() to check if packages are installed. If they are, they will be launched into R. The packages installed are\n\nplotly: Used for creating interactive web-based graphs.\nggstatsplot: Used for creating graphics with details from statistical tests.\nknitr: Used for dynamic report generation\npacthwork: Used to combine plots\nggdist: Used for visualising distribution and uncertainty\nggthemes: Provide additional themes for ggplot2\ntidyverse: A collection of core packages designed for data science, used extensively for data preparation and wrangling.\nAll packages can be found within CRAN.\n\n\n#Load packages\npacman::p_load(plotly, ggstatsplot, knitr, patchwork, ggdist, ggthemes, tidyverse)\n\nImport data from csv using readr::read_csv() and store it in variable flatprice.\n\n#Import data\nflatprice <- read_csv(\"data/resale-flat-prices-based-on-registration-date-from-jan-2017-onwards.csv\", show_col_types = FALSE)\n\n\n\n\n\n\n2.2 Data wrangling\nLooking at the data below, we notice few problems\n\nmonth is in <chr> format (“yyyy-mm”), which is not very useful for filtering for 2022 period\nlease_commence_date is in <dbl> format. It needs to be converted to <chr>\nremaining_lease is in <chr> format. It needs to be reformatted to <dbl> in years\n\n\nflatprice\n\n# A tibble: 146,215 × 11\n   month   town    flat_…¹ block stree…² store…³ floor…⁴ flat_…⁵ lease…⁶ remai…⁷\n   <chr>   <chr>   <chr>   <chr> <chr>   <chr>     <dbl> <chr>     <dbl> <chr>  \n 1 2017-01 ANG MO… 2 ROOM  406   ANG MO… 10 TO …      44 Improv…    1979 61 yea…\n 2 2017-01 ANG MO… 3 ROOM  108   ANG MO… 01 TO …      67 New Ge…    1978 60 yea…\n 3 2017-01 ANG MO… 3 ROOM  602   ANG MO… 01 TO …      67 New Ge…    1980 62 yea…\n 4 2017-01 ANG MO… 3 ROOM  465   ANG MO… 04 TO …      68 New Ge…    1980 62 yea…\n 5 2017-01 ANG MO… 3 ROOM  601   ANG MO… 01 TO …      67 New Ge…    1980 62 yea…\n 6 2017-01 ANG MO… 3 ROOM  150   ANG MO… 01 TO …      68 New Ge…    1981 63 yea…\n 7 2017-01 ANG MO… 3 ROOM  447   ANG MO… 04 TO …      68 New Ge…    1979 61 yea…\n 8 2017-01 ANG MO… 3 ROOM  218   ANG MO… 04 TO …      67 New Ge…    1976 58 yea…\n 9 2017-01 ANG MO… 3 ROOM  447   ANG MO… 04 TO …      68 New Ge…    1979 61 yea…\n10 2017-01 ANG MO… 3 ROOM  571   ANG MO… 01 TO …      67 New Ge…    1979 61 yea…\n# … with 146,205 more rows, 1 more variable: resale_price <dbl>, and\n#   abbreviated variable names ¹​flat_type, ²​street_name, ³​storey_range,\n#   ⁴​floor_area_sqm, ⁵​flat_model, ⁶​lease_commence_date, ⁷​remaining_lease\n\n\nis.na() function is also used to confirm that there are no missing values in the flatprice dataset.\n\n#Check for missing values\nany(is.na(flatprice))\n\n[1] FALSE\n\n\nThe code chunk below performs the required data wrangling to clean flatprice dataset and store it in new variable flatpriceclean.\n\nFilter flat_type for 3 ROOM, 4 ROOM, and 5 ROOM as this is the scope of the study using dplyr::filter()\nConvert the month variable to date using as.Date(). Store the year and month to the respective new variables year and month using dplyr:mutate(). They can then be converted to string (discrete variables) using as.character(). Afterwards, we can filter the year variable to 2022 using dplyr::filter(), which is the scope of the study\nExtract the year and month digits from remaining_lease variable using str_extract() function. Sum the year digits and (month digits/12) to obtain the years of remaining lease and convert it to <dbl> format using as.numeric(). They are then rounded to 1 decimal place using round(). Assign new variable called remaining_lease_years using dplyr::mutate()\n\n\n\n\n\n\n\nTip\n\n\n\nWith str_extract() function, we can use regular expression like \"^[0-9]+\" to extract the year digits and \" [0-9]+\" to extract the month digits. Note the special character '^' indicates the beginning of string to extract year digits since the year digits is always at the beginning of the string. The blank space ' ' preceding the regular expression to extract month digits match the second digits of remaining_lease, which represent the month digits.\n\n\n\nCreate new variable called resale_price_persqm to divide the resale_price with floor_area_sqm. This is performed to normalize the resale price to flat area. They are then rounded to 1 decimal place using round(). The new variable is assigned using dplyr::mutate\nConvert lease_commence_date to <int> using as.integer() as it reflects year of starting lease, which is in ordinal scale\nUse dplyr::select() to select only the relevant variables (month, town, flat_type, storey_range, floor_area_sqm, flat_model, lease_commence_date, remaining_lease_years, resale_price_persqm, resale_price)\n\n\n#Data preparation\n#store the new dataset in new variable flatpriceclean\nflatpriceclean <- flatprice |> \n  \n#filter for 3-ROOM, 4-ROOM, 5-ROOM\n  filter(flat_type %in% c('3 ROOM','4 ROOM','5 ROOM')) |> \n  \n#reformat month and split it to month and year. Use year to filter for 2022\n  mutate(year = as.character(format(as.Date(paste(month, \"-01\", sep=\"\")), \"%Y\")),\n         month = as.character(format(as.Date(paste(month, \"-01\", sep=\"\")), \"%m\")),\n         .before = 1)|> \n  filter(year == 2022) |> \n\n#mutate remaining_lease to remaining_lease_years\n  mutate(remaining_lease_years = round((as.numeric(str_extract(remaining_lease, \"^[0-9]+\")) + \n                           ifelse(is.na(as.numeric(str_extract(remaining_lease, \" [0-9]+\"))), 0, as.numeric(str_extract(remaining_lease, \" [0-9]+\")))/12), digits = 1),\n         \n#create new variable called resale_price_persqm\n         resale_price_persqm = round(resale_price/floor_area_sqm, digits = 1),\n\n#convert lease_commence_date to integer\n         lease_commence_date = as.integer(lease_commence_date),\n         .after = remaining_lease) |> \n\n#select relevant variable\n  select(c(2:4, 7:10, 12:14))\n\nThe final dataset flatpriceclean is displayed below using knitr::kable() function.\n\nkable(head(flatpriceclean), \"simple\")\n\n\n\n\nmonth\ntown\nflat_type\nstorey_range\nfloor_area_sqm\nflat_model\nlease_commence_date\nremaining_lease_years\nresale_price_persqm\nresale_price\n\n\n\n\n01\nANG MO KIO\n3 ROOM\n07 TO 09\n73\nNew Generation\n1977\n54.4\n4904.1\n358000\n\n\n01\nANG MO KIO\n3 ROOM\n07 TO 09\n67\nNew Generation\n1978\n55.1\n5298.5\n355000\n\n\n01\nANG MO KIO\n3 ROOM\n07 TO 09\n68\nNew Generation\n1981\n58.0\n4970.6\n338000\n\n\n01\nANG MO KIO\n3 ROOM\n07 TO 09\n82\nNew Generation\n1980\n57.2\n5122.0\n420000\n\n\n01\nANG MO KIO\n3 ROOM\n04 TO 06\n67\nNew Generation\n1980\n57.1\n4895.5\n328000\n\n\n01\nANG MO KIO\n3 ROOM\n01 TO 03\n83\nNew Generation\n1979\n56.6\n4337.3\n360000"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#visualization",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#visualization",
    "title": "Take-home Exercise 3",
    "section": "3. Visualization",
    "text": "3. Visualization\n\n3.1 Exploratory Data Visualization\nThe first plot purpose is to provide preliminary insight on the resale price of property vs remaining lease. the plot looks very cluttered as the number of dataset is high, however, this is deemed to be sufficient for preliminary analysis. Note that the resale price is normalized with floor area, as absolute resale price tends to be more expensive for bigger area.\nThe first plot design consideration :\n\nColor legend for flat type (3 ROOM, 4 ROOM, 5 ROOM) in plotly allows users to filter accordingly\nHover tip displaying the resale price, floor area, remaining lease, and flat type\n\n\n\nShow the code\nplot_ly(data = flatpriceclean,\n        x = ~remaining_lease_years,\n        y = ~resale_price_persqm,\n        hovertemplate = ~paste(\"<br>Resale Price per sqm:\", resale_price_persqm,\n                               \"<br>Floor Area (sqm):\", floor_area_sqm,\n                               \"<br>Remaining Lease (Year):\", remaining_lease_years),\n        type = 'scatter',\n        mode = 'markers',\n        color = ~flat_type,\n        marker = list(opacity = 0.6,\n                      sizemode = 'diameter',\n                      line = list(width = 0.2, color = '#FFFFFF'))) |> \n  \n  layout(title = \"Resale Price per flat area increases with remaining lease \\nResale transactions, 2022\",\n         xaxis = list(title = \"Remaining Lease (Year)\"),\n         yaxis = list(title = \"Resale Price per sqm (SGD)\"),\n         legend = list(orientation = 'h',\n                       xref = \"paper\",\n                       yref = \"paper\",\n                       xanchor = \"center\",\n                       yanchor =\"top\",\n                       x = 0.5,\n                       y = 0.95))\n\n\n\n\n\n\nUsing updatemenus to get a good first glance of all relationships\n\n\nShow the code\nflatpriceclean$flat_model <- fct_reorder(flatpriceclean$flat_model, flatpriceclean$resale_price_persqm)\n\nplot_ly(data = flatpriceclean,\n        x = ~flat_type,\n        y = ~resale_price_persqm,\n        type = \"violin\",\n        alpha = 0.3,\n        marker = list(opacity = 0.6),\n        box = list(visible = T),\n        meanline = list(visible = T)) |> \n  \n  layout(title = \"Distribution of resale price by selected factors, \\nResale transactions, 2022\",\n         xaxis = list(title = \"\"),\n         yaxis = list(title = \"Resale Price per sqm (SGD)\"),\n         updatemenus = list(list(type = 'dropdown',\n                                 xref = \"paper\",\n                                 yref = \"paper\",\n                                 xanchor = \"left\",\n                                 x = 0.04, \n                                 y = 0.95,\n                                 buttons = list(\n                                   list(method = \"update\",\n                                        args = list(list(x = list(flatpriceclean$flat_type)),\n                                                    list(xaxis = list(categoryorder = \"category ascending\"))),\n                                        label = \"Flat Type\"),\n                                   list(method = \"update\",\n                                        args = list(list(x = list(flatpriceclean$flat_model)),\n                                                    list(xaxis = list(categoryorder = \"mean ascending\"))),\n                                        label = \"Flat Model\"),\n                                   list(method = \"update\",\n                                        args = list(list(x = list(flatpriceclean$storey_range)),\n                                                    list(xaxis = list(categoryorder = \"category ascending\"))),\n                                        label = \"Storey Height\"),\n                                   list(method = \"update\",\n                                        args = list(list(x = list(flatpriceclean$town)),\n                                                    list(xaxis = list(categoryorder = \"mean ascending\"))),\n                                        label = \"Town\"),\n                                   list(method = \"update\",\n                                        args = list(list(x = list(flatpriceclean$month)),\n                                                    list(xaxis = list(tickmode = \"array\")),\n                                                    list(color = list(flatpriceclean$month))),\n                                        label = \"Transaction Month\")\n                              \n                                   )\n                                 )\n                            )\n         )\n\n\n\n\n\n\n\n\n3.2 Confirmatory Data Analysis Visualization\nThe first plot is to investigate other factors that might impact the resale price.\n\n\nShow the code\nggbetweenstats(\n  data = flatpriceclean,\n  x = flat_type, \n  y = resale_price_persqm, \n  xlab = \"Types of Flat (Rooms)\",\n  ylab = \"Resale Price per sqm (SGD)\",\n  palette = \"Paired\",\n  title = \"One-way ANOVA analysis reveals at least one significant difference in 2022 resale price across different flat types\",\n  type = \"np\", \n  pairwise.comparisons = TRUE,\n  pairwise.display = \"ns\", \n  mean.ci = TRUE, \n  p.adjust.method = \"fdr\", \n  messages = FALSE \n  ) \n\n\n\n\n\nThe second plot is to investigate other factors that might impact the resale price.\n\n\nShow the code\nggbetweenstats(\n  data = flatpriceclean |> \n    mutate(storey_range = ifelse(storey_range %in% c(\"40 TO 42\", \"43 TO 45\", \"46 TO 48\", \"49 TO 51\"), \"40+\", storey_range)), \n  x = storey_range, \n  y = resale_price_persqm, \n  xlab = \"Storey Height\",\n  ylab = \"Resale Price per sqm (SGD)\",\n  palette = \"Paired\",\n  title = \"One-way ANOVA analysis reveals at least one significant difference in 2022 resale price across different storeys\",\n  type = \"np\", \n  pairwise.comparisons = TRUE,\n  pairwise.display = \"ns\", \n  mean.ci = TRUE, \n  p.adjust.method = \"fdr\", \n  messages = FALSE \n  ) \n\n\n\n\n\nThirdly, check the flat_model variables. Filtering for number of observations >= 50\n\n\nShow the code\nflatpriceclean$flat_model <- fct_reorder(flatpriceclean$flat_model, flatpriceclean$resale_price_persqm)\n\nggbetweenstats(\n  data = flatpriceclean |> \n    group_by(flat_model) |> \n    filter(n() >= 50),\n  x = flat_model, \n  y = resale_price_persqm, \n  xlab = \"Flat Model\",\n  ylab = \"Resale Price per sqm (SGD)\",\n  palette = \"Paired\",\n  title = \"One-way ANOVA analysis reveals at least one significant difference in 2022 resale price across different models\",\n  type = \"np\", \n  pairwise.comparisons = TRUE,\n  pairwise.display = \"ns\",  \n  mean.ci = TRUE, \n  p.adjust.method = \"fdr\", \n  messages = FALSE \n  ) \n\n\n\n\n\nThe town variables are skipped as there are too many variables -> to be considered in the final visualization\nLastly, check the transaction month variables\n\n\nShow the code\nggbetweenstats(\n  data = flatpriceclean,\n  x = month, \n  y = resale_price_persqm, \n  xlab = \"Month of Transaction\",\n  ylab = \"Resale Price per sqm (SGD)\",\n  palette = \"Paired\", \n  title = \"One-way ANOVA analysis reveals at least one significant difference in 2022 resale price across different \\ntransaction months\",\n  type = \"np\", \n  pairwise.comparisons = TRUE,\n  pairwise.display = \"ns\",   \n  mean.ci = TRUE, \n  p.adjust.method = \"fdr\", \n  messages = FALSE \n  ) \n\n\n\n\n\n\n\n3.3 Visualization of Resale Price by Township\n\n\nShow the code\ntown_list <- list()\nfor (i in 1:length(unique(flatpriceclean$town))) { \n  town_list[[i]] <- list(method = \"restyle\",\n                         args = list(\"transforms[0].value\",\n                                     unique(flatpriceclean$town)[i]),\n                         label = unique(flatpriceclean$town)[i])\n  }\n\nannot <- list(list(text = \"Select Towns:\",\n                   x = 1.41,\n                   y = 0.78,\n                   xref = 'paper',\n                   yref = 'paper',\n                   showarrow = FALSE))\n\n\n\n\nShow the code\nflatpriceorder <- flatpriceclean[order(flatpriceclean$flat_type), ]\n\nplot_ly(data = flatpriceclean,\n        x = ~remaining_lease_years,\n        y = ~resale_price_persqm,\n        hovertemplate = ~paste(\"<br>Resale Price per sqm:\", resale_price_persqm,\n                               \"<br>Floor Area (sqm):\", floor_area_sqm,\n                               \"<br>Remaining Lease (Year):\", remaining_lease_years,\n                               \"<br>Town:\", town),\n        type = 'scatter',\n        mode = 'markers',\n        size = ~floor_area_sqm,\n        sizes = c(5, 15),\n        color = ~factor(flat_type),\n        marker = list(opacity = 0.6,\n                      sizemode = 'diameter',\n                      line = list(width = 0.2, color = '#FFFFFF')),\n        transforms = list(list(type = 'filter',\n                               target = ~flatpriceorder$town,\n                               operation = '=',\n                               value = unique(flatpriceorder$town)[1])\n                          )\n        ) |> \n  \n  layout(title = \"Resale Price per flat area increases with remaining lease \\nResale transactions by towns, 2022\",\n         xaxis = list(title = \"Remaining Lease (Year)\",\n                      range = c(40, 100)),\n         yaxis = list(title = \"Resale Price per sqm (SGD)\",\n                      range = c(3000, 16000)),\n         updatemenus = list(list(type = 'dropdown',\n                                 xref = \"paper\",\n                                 yref = \"paper\",\n                                 x = 1.4, y = 0.7,\n                                 buttons = town_list)\n                            ),\n         \n         annotations = annot\n         )"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#visualisation",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#visualisation",
    "title": "Take-home Exercise 3",
    "section": "3. Visualisation",
    "text": "3. Visualisation\n\n3.1 Exploratory Data Visualisation\nThe plots here are preliminary in nature but designed with interactivity to allow users to perform Exploratory Data Analysis (EDA) Visualisation to study the data. Hence plotly is mainly used.\n\n\n\n\n3.1.1. Interactive scatterplot\n\nDesign Consideration\nScatterplots are generally used to discover relationship between two continuous variables. As such, the visualization below allows users to select the x-axis and y-axis of the continuous variables they wish to study. Considerations :\n\nDropdown menu to select variables for y-axis and x-axis\ny-axis selection is resale_price and resale_price_persqm. This is aligned with the study purpose of discovering patterns of resale price. This allows users to also see the intent of normalising resale_price by floor_area_sqm\nx-axis selection is other continuous variables, namely: remaining_lease_years, lease_commence_date, and floor_area_sqm\nAs the plots are expected to be very cluttered, opacity is introduced with white border\nTooltip indicating variables of interest : remaining_lease_years, floor_area_sqm, and resale_price_persqm\n\n\n\nPreparation of visualisation\nplot_ly is used to prepare the interactive plot. Steps taken are\n\nInitiating base scatterplot, indicated by type = 'scatter'. marker argument is used to introduce opacity and line (white plot border)\nTooltip customisation is created using hovertemplate argument\nlayout argument is used to add plot title, x-axis title, and y-axis title\nTo create the dropdown menu for parameters of x-axis and y-axis, the updatemenus argument is used to create respective buttons\n\n\n\n\n\n\n\nTip\n\n\n\nupdatemenus argument takes a list of list of arguments detailing the type, direction, and position of the menus. Additionally, it has buttons argument that takes another list of list of arguments detailing the method, args (x-axis/y-axis variable), and labels. Note that update is chosen in method as we want to modify data and layout attributes. Refer to here for additional information.\n\n\nRefer to code below for more details\n\n\nShow the code\n#Initiating the base plot\nplot_ly(data = flatpriceclean,\n        x = ~remaining_lease_years,\n        y = ~resale_price_persqm,\n        hovertemplate = ~paste(\"<br>Resale Price per sqm:\", resale_price_persqm,\n                               \"<br>Floor Area (sqm):\", floor_area_sqm,\n                               \"<br>Remaining Lease (Year):\", remaining_lease_years),\n        type = 'scatter',\n        mode = 'markers',\n        marker = list(opacity = 0.6,\n                      sizemode = 'diameter',\n                      line = list(width = 0.2, color = 'white'))) |> \n\n#Generating plot, x-axis, and y-axis title\n  layout(title = \"Interactive scatterplot of resale price vs selected factors\\nResale transactions, 2022\",\n         xaxis = list(title = \"Remaining Lease (Year)\"),\n         yaxis = list(title = \"Resale Price per sqm (SGD)\"),\n         \n#creating dropwdown menus to allow selection of parameters on x-axis and y-axis \n         updatemenus = list(list(type = \"dropdown\",\n                                 direction = \"up\",\n                                 xref = \"paper\",\n                                 yref = \"paper\",\n                                 xanchor = \"left\",\n                                 yanchor = \"top\",\n                                 x = 1,\n                                 y = 0,\n                                 buttons = list(\n                                   list(method = \"update\",\n                                        args = list(list(x = list(flatpriceclean$remaining_lease_years)),\n                                                    list(xaxis = list(title = \"Remaining Lease (Year)\"))),\n                                        label = \"Remaining Lease\"),\n                                   list(method = \"update\",\n                                        args = list(list(x = list(flatpriceclean$lease_commence_date)),\n                                                    list(xaxis = list(title = \"Year of Lease Commenced\"))),\n                                        label = \"Lease Commenced\"),\n                                   list(method = \"update\",\n                                        args = list(list(x = list(flatpriceclean$floor_area_sqm)),\n                                                    list(xaxis = list(title = \"Floor Area (sqm)\"))),\n                                        label = \"Floor Area\")\n                                   )\n                                 ),\n                            \n                            list(type = \"dropdown\",\n                                 xref = \"paper\",\n                                 yref = \"paper\",\n                                 xanchor = \"left\",\n                                 yanchor = \"top\",\n                                 x = 0.04,\n                                 y = 0.95,\n                                 buttons = list(\n                                   list(method = \"update\",\n                                        args = list(list(y = list(flatpriceclean$resale_price_persqm)),\n                                                    list(yaxis = list(title = \"Resale Price per sqm (SGD)\"))),\n                                        label = \"Resale Price/Area\"),\n                                   list(method = \"update\",\n                                        args = list(list(y = list(flatpriceclean$resale_price)),\n                                                    list(yaxis = list(title = \"Resale Price (SGD)\"))),\n                                        label = \"Resale Price\")\n                                   )\n                                 )\n                            )\n         )\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nSelect the relevant x-variable and y-variable in the dropdown box in the graph above to study the different scatterplot of resale price by different cotninuous variables\n\n\n\n\nInsights\n\nThe most obvious pattern is the direct positive correlation between resale price and floor area. Hence the decision to normalize the resale price is justified. From here onwards, we will focus more on resale price per sqm.\nPlotting resale price per sqm vs remaining lease reveals somewhat positive exponential correlation. There seems to sharper increase in gradient if the remaining lease is beyond 80 years\nAs expected, the same pattern is revealed when resale price per sqm is plotted against the year of lease commenced.\n\n\n\nShow the code\nggplot(data = flatpriceclean)+\n\n  geom_point(aes(x = lease_commence_date,\n                 y = remaining_lease_years)) +\n  \n  labs(\n    x = \"Year of Lease Commenced\",\n    y = \"Remaining Lease\\n(Year)\") +\n\n  theme(axis.title.y = element_text(angle = 0))\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nReferring to the graph above, year of lease commenced and remaining lease are directly correlated to each other as shown in above plot. Hence it makes sense to use one of them in future analysis. In this case, we will only use remaining lease as it is more intuitive.\n\n\n\n\n\n\n\n\n3.1.2. Interactive boxviolin plot\n\nDesign Consideration\nIn contrast to scatterplots, boxplots are generally used to discover relationship between continuous variables and discrete variables. Violin plots can also be added to visualize the kernel density of the data.\nAs such, the visualization below allows users to select the x-axis of the discrete variables they wish to study. Considerations :\n\nDropdown menu to select variables for x-axis\ny-axis selected is resale_price_persqm. This is aligned with the study purpose of discovering patterns of resale price\nx-axis selection is the discrete variables, namely: flat_type, flat_model, storey_range, town, and month. Note that month (transaction month) is treated as discrete variable as we want to find out any seasonal variations (statistically significant difference in mean/median) of price.\nx-axis title is omitted as it will be displayed by the selected dropdown menu\nCombining boxplots and violin plots to visualize the quartiles and kernel density of the distribution\nTooltip to show mean, quartiles, and outliers\nPlot can be zoomed-in or out as it might be difficult to get details with large number of categories (i.e., town)\nOrder the variables by ascending order (mean) if they are not lexicographically important (i.e., flat_type, storey_range, and month\n\n\n\nPreparation of visualisation\nplot_ly is used to prepare the interactive plot. Steps taken are\n\nInitiating base scatterplot, indicated by type = 'violin'. Note box visible argument is set to T to ensure the boxplot is visible. The same is applied to meanline visible to ensure meanline is visible in color \"rgb(231, 99, 250)\"\nSet the opacity of the dots to 0.5 and the color of the meanline to dark pink to improve visualisation\nlayout argument is used to add plot title, and y-axis title\nTo create the dropdown menu for parameters of x-axis, the updatemenus argument is used to create respective buttons\ncategoryorder is set for each button to determine the order of discrete variables. category ascending will ensure lexicographic order while mean ascending will ensure mean order.\n\nRefer to code below for more details\n\n\nShow the code\n#Initiating the base plot\nplot_ly(data = flatpriceclean,\n        x = ~flat_type,\n        y = ~resale_price_persqm,\n        line = list(width =1),\n        type = \"violin\",\n        marker = list(opacity = 0.5,\n          line = list(width = 2)),\n        box = list(visible = T),\n        meanline = list(visible = T,\n                        color = \"rgb(231, 99, 250)\")) |> \n  \n#Generating plot and y-axis title  \n  layout(title = \"Distribution of resale price by selected factors \\nResale transactions, 2022\",\n         xaxis = list(title = \"\"),\n         yaxis = list(title = \"Resale Price per sqm (SGD)\"),\n         \n#creating dropwdown menus to allow selection of parameters on x-axis \n         updatemenus = list(list(type = 'dropdown',\n                                 xref = \"paper\",\n                                 yref = \"paper\",\n                                 xanchor = \"left\",\n                                 x = 0.04, \n                                 y = 0.95,\n                                 buttons = list(\n                                   list(method = \"update\",\n                                        args = list(list(x = list(flatpriceclean$flat_type)),\n                                                    list(xaxis = list(categoryorder = \"category ascending\"))),\n                                        label = \"Flat Type\"),\n                                   list(method = \"update\",\n                                        args = list(list(x = list(flatpriceclean$flat_model)),\n                                                    list(xaxis = list(categoryorder = \"mean ascending\"))),\n                                        label = \"Flat Model\"),\n                                   list(method = \"update\",\n                                        args = list(list(x = list(flatpriceclean$storey_range)),\n                                                    list(xaxis = list(categoryorder = \"category ascending\"))),\n                                        label = \"Storey Height\"),\n                                   list(method = \"update\",\n                                        args = list(list(x = list(flatpriceclean$town)),\n                                                    list(xaxis = list(categoryorder = \"mean ascending\"))),\n                                        label = \"Town\"),\n                                   list(method = \"update\",\n                                        args = list(list(x = list(flatpriceclean$month)),\n                                                    list(xaxis = list(tickmode = \"array\")),\n                                                    list(color = list(flatpriceclean$month))),\n                                        label = \"Transaction Month\")\n                              \n                                   )\n                                 )\n                            )\n         )\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nSelect the relevant x-variable (groups) in the dropdown box in the graph above to study the boxviolin plot of resale price per area by different groups\n\n\n\n\nInsights\nNote that insights can be garnered by zooming in some plots with high number of categories\n\nWhen plotted by flat_type, preliminary EDA reveals minimal difference between the means/medians. This is expected since we are using resale_price_persqm. Note that flats with more rooms tend to be bigger in area, hence when normalized by area, the difference in resale price among different types of flat is minimized. It is interesting to note that 5 ROOM flat type has the lowest mean overall.\nWhen plotted by flat_model, preliminary EDA reveals higher mean/median resale_price_persqm for models like DBSS, Terrace, Premium, S2 and S1. However, it is important to note that these types tend to be few in the market as well. Note large variance are observed for improved and Model A types.\nWhen plotted by storey_range, preliminary EDA reveals higher mean/median resale_price_persqm for higher storey. Note large outliers are observed for 19 to 27th storey units.\nWhen plotted by town, preliminary EDA reveals differences in mean/median resale_price_persqm for different town estates. At the lower end, we can find newly developed or further towns (i.e., Woodlands, Pasir Ris, Jurong West), while at the opposite end, we find more mature or centrally located towns (i.e., Central Area, Queenstown, Kallang/Whampoa). Note that the data looks skewed right with most of the towns’ means are higher than the medians and high presence of outlier on the higher end.\nPreliminary EDA reveals minimal difference in resale_price_persqm between transaction months.\n\nHowever, these observations need to be confirmed using appropriate hypothesis techniques. Since the focus of the study is on resale price by residential towns, only this will be considered.\n\n\n\n\n\n\n\n3.2 Confirmatory Data Analysis Visualisation\nThe plots here are focused in visual statistical testing used in Confirmatory Data Analysis. Hence ggstatsplot is mainly used.\n\nNormality Assumption\nBefore performing the necessary hypothesis testing, we need to choosen between parametric and non-parametric test. As such nortest::ad.test() will be used to perform Anderson-Darling test with confidence level of 95% to test the null hypothesis that the resale price per area by town is normally distributed.\nfor-loop is used to iterate through each unique town to create a list called normaltestlist containing a list of Anderson-Darling test results. A tibble called normaltest is then created containing the town variable and p_value result of the Anderson-Darling test. DT::datatable() is then used to create interactive data table.\nRefer to code below for more details\n\nnormaltestlist <- list()\nfor (i in unique(flatpriceclean$town)){\n  subdf <- subset(x = flatpriceclean, subset=town==i)\n  normaltestlist[[i]] <- nortest::ad.test(subdf$resale_price_persqm)\n}\n\nnormaltest <- tibble(town = unique(flatpriceclean$town),\n                        p_value = unlist(lapply(normaltestlist, `[[`, 2)))\n\nDT::datatable(normaltest, class= \"compact\")\n\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nBased on the result above, the null hypothesis is rejected as some of the distributions are below 0.05 critical value. As such, we are not able to confirm normality assumption for distribution of resale price per area by town.\n\n\n\n\nDesign Consideration\n\n\n\n\n\n\nImportant\n\n\n\nSince we are unable to confirm normality assumption, non-parametric test (Kruskal-Wallis) will be used for hypothesis testing. Note that the null hypothesis is no difference between median resale price per area by towns/estates.\n\n\nTo ensure that best practices (APA standard) of statistical reporting is followed, ggstatsplot library is used in this section. Considerations :\n\nAs revealed by EDA, town variables have 26 categories. Hence ggbetweenstats will be used for one-way ANOVA testing.\nMedian is used instead of mean as point estimates due to high presence of outliers and skewness of data. This will also complement the non-parametric test as well.\nGiven the large number of categories, two plots are considered, splitting the towns seeing >= 850 transactions and those seeing <850 transactions in 2022. This is mainly to ensure that the selected towns can fit in single plot (13 towns each) as having 26 towns in one single plot causes it to be too cluttered. This also helps to reduce bias against variations in number of observations. Note that the y-axis range needs to be fixed for the two plots for easier comparison.\n\n\n\nPreparation of visualisation\nggstatsplot is used to prepare the plot. Steps taken are\n\nOrder the towns by the median of resale_price_persqm in ascending order using forcats::fct_reorder. This will ensure the towns are ordered accordingly for easier observation.\nggstatsplot::ggbetweenstats() is used to display the one-way ANOVA plot. Note that the dataset is grouped by town and filtered when count >=850. This is achieved using dplyr::group_by() and dplyr::filter()\nAs above design consideration, non-parametric test is considered hence type = \"np\"\nComparisons are made pairwise between non-significant pairs as they are the points of interest. Note that the majority of the pairs comparison are significant as well, hence it will clutter the plots unnecessarily if significant pairwise comparison is displayed. The argument pairwise.display = \"ns\"\nTwo plots are created and assigned to p1 and p2 respectively\nTwo sets of color are manually provided using scale_color_manual of ggplot2. This is because the basic palette is not able to support large number of colors (26)\nscale_y_continuous is used to set the y-axis range between 4,000 and 20,000\npatchwork is added to combine the two plots using operator /\nplot_annotation() is used to configure the title, subtitle and caption of the combined visualisation\n\nRefer to code below for more details\n\n\nShow the code\n#Order the town variables by median of resale price\nflatpriceclean$town <- fct_reorder(flatpriceclean$town, flatpriceclean$resale_price_persqm, median)\n\n#set the color pallete\ncol13_1 <- c(\"dodgerblue2\", \"#E31A1C\", \n  \"green4\",\n  \"#6A3D9A\", \n  \"#FF7F00\", \n  \"gray30\", \"gold1\",\n  \"skyblue2\", \"#FB9A99\", \n  \"palegreen2\",\n  \"#CAB2D6\", \n  \"#FDBF6F\", \n  \"gray80\") \n  \ncol13_2 <- c(\"khaki2\",\n  \"maroon\", \"orchid1\", \"deeppink1\", \"blue1\", \"steelblue4\",\n  \"darkturquoise\", \"green1\", \"yellow4\", \"yellow3\",\n  \"darkorange4\", \"brown\", \"gray50\")\n\n#Initiating the base plot\np1 <- ggbetweenstats(\n  data = flatpriceclean|> \n    group_by(town) |> \n    filter(n() >= 850),\n  x = town, \n  y = resale_price_persqm, \n  ylab = \"Resale Price per sqm (SGD)\",\n  title = \"Plot 1. One-way ANOVA (towns >= 850 transactions)\",\n  type = \"np\", \n  pairwise.comparisons = TRUE,\n  pairwise.display = \"ns\",\n  mean.ci = TRUE,\n  p.adjust.method = \"fdr\", \n  messages = FALSE \n  ) +\n  scale_color_manual(values = col13_1) +\n  theme(axis.title.x = element_blank()) +\n  scale_y_continuous(limits = c(4000, 20000))\n\np2 <- ggbetweenstats(\n  data = flatpriceclean|> \n    group_by(town) |> \n    filter(n() < 850),\n  x = town, \n  y = resale_price_persqm, \n  xlab = \"Planning Town\",\n  ylab = \"Resale Price per sqm (SGD)\",\n  title = \"Plot 2. One-way ANOVA (towns < 850 transactions)\",\n  type = \"np\", \n  pairwise.comparisons = TRUE,\n  pairwise.display = \"ns\",\n  mean.ci = TRUE,\n  p.adjust.method = \"fdr\", \n  messages = FALSE \n  ) +\n  scale_color_manual(values = col13_2) +\n  scale_y_continuous(limits = c(4000, 20000))\n\nfinal_plot <- p1/p2\nfinal_plot + plot_annotation(\n  title = 'One-way ANOVA reveals differences in 2022 resale price across different towns',\n  subtitle = 'Resale price per flat area by Town, 2022',\n  caption = 'Resale flat princes based on registration date from Jan-2017 onwards from data.gov.sg',\n  theme = theme(plot.title = element_text(face = \"bold\", size = 18))\n)\n\n\n\n\n\n\n\nInsights\nAs noted above, the hypothesis testing is done using Kruskal-Wallis test with 95% confidence level for the individual plot. For each plot, they hypothesis is:\n\nH0 : There is no difference between median resale price per flat area across towns\nH1 : There is difference between median resale price per flat area across towns\n\n\n\n\n\n\n\nImportant\n\n\n\nSince the p-value < critical value of 0.05, there is statistical evidence to reject the null hypothesis. We can conclude that for each group of towns (grouped by number of transactions), there is difference between median resale price per flat area.\n\n\nIn both plots, it can be observed that there are few pairs of towns with p-value > 0.05 such as Jurong West and Choa Chu Kang. This suggests that the differences between the medians of the pair are not statistically significant.\nWe can also observe that there is overall higher median and higher number of towns with significant outliers (i.e., Central Area, Queenstown, Toa Payoh, Bishan, Clementi) in the second plot (towns with < 850 transactions).\nOverall, the findings of the EDA is more or less consistent (refer to section 3.1.2 above).\n\n\n\n\n\n\n3.3 Visualising the uncertainty of point estimates\nIt is tempting to interpret point estimate like median as precise representation of the true data value. However, it is worth noting that there are uncertainties surrounding the point estimates, hence the motivation to display the the target quantile confidence levels (95% or 99%) that the true (unknown) estimate would lie within the interval, given the evidence provided by the observed data.\n\nDesign Consideration\nggdist::stat_pointinterval() is used to visualise the uncertainty. Considerations :\n\nMedian point estimates are used instead of mean due to high presence of outliers and skewness of data. With this, user can still relate to the above one-way ANOVA analysis\nWith median used as point estimate, quantile interval is used instead of confidence interval\n95% and 99% intervals are used as they are commonly associated with 5% and 1% error rate, which are commonly used in hypothesis testing\n\n\n\n\n\n\n\nTip\n\n\n\nThe aim is to provide one-glance of levels of uncertainties of median estimate of resale price by town. Hence there is no need to clutter the plot with too much details (i.e., labels and annotations) and it is possible to present this in a single plot\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIt is important to use quantile interval for median point estimates instead of using typical confidence intervals. As with all nonparametric confidence intervals, the exact confidence level is not always attainable but the level which is exact to the interval constructed is displayed.\n\n\n\n\nPreparation of visualisation\nggplot2 and stat_pointinterval() are used to prepare the plot. Steps taken are\n\nUse the base ggplot() to determine the data and x, y-variables\nDefine confidence levels in width argument of stat_pointinterval(). Define the .point estimate as median and .interval as qi (quantile intervals). The argument point_color also assigns color to the point.\nscale_color_manual() of ggplot2 is used to assign colors for the interval lines (95% and 99%). Note that the colors chosen are only slightly different, just enough to distinguish the closely related interval lines.\nSetting the title, subtitle and caption using lab() and theme() of ggplot2\n\n\n\nShow the code\n#Base ggplot\nggplot(\n  data = flatpriceclean,\n  aes(x = town,\n      y = resale_price_persqm)) +\n  \n#Using stat_pointinterval to plot the points and intervals\n  stat_pointinterval(\n    aes(interval_color = stat(level)),\n    .width = c(0.95, 0.99),\n    .point = median,\n    .interval = qi,\n    point_color = \"darkred\",\n    show.legend = FALSE) +\n\n#Defining the color of the intervals \n  scale_color_manual(\n    values = c(\"blue2\", \"darkblue\"),\n    aesthetics = \"interval_color\") +\n  \n#Title, subtitle, and caption\n  labs(title = 'Visualising uncertainty in median estimates of resale price by town',\n  subtitle = 'Quantiles intervals (95% and 99%) of resale price per flat area by Town, 2022',\n  caption = 'Resale flat princes based on registration date from Jan-2017 onwards from data.gov.sg',\n  x = \"Planning Town\",\n  y = \"Resale Price per sqm (SGD)\") +\n  \n  theme_hc() +\n  \n  theme(plot.title = element_text(face = \"bold\", size = 18),\n        plot.subtitle = element_text(size = 14),\n        axis.text.x = element_text(angle = 30, hjust = 1))\n\n\n\n\n\n\n\nInsights\nAs noted above, some towns like Central Area, Bukit Merah, and Bishan have higher uncertainties. This could be potentially due to large presence of outliers in those towns, more varied flat types or models. On the opposite spectrum, towns like Choa Chu Kang, Sembawang and Bukit Timah have lower uncertainties, which might indicate lower presence of outliers or more uniform flat types.\n\n\n\n\n\n\n3.4 Visualisation of Resale Price vs Remaining Lease by Township\nSection 3.1 above allow users to perform EDA to explore the relationship between resale price with other variables. Section 3.2 confirms statistical evidence of difference of resale price by towns. It is hence interesting to combine these insights together in one interactive visualization.\n\nDesign Consideration\nOne of the most interesting finding in EDA in Section 3.1.1 is the relationship between resale price per sqm and remaining lease_years. Unfortunately, without applying any filters, there is very little insight that can be garnered from this two-dimensional plot. Additional dimensions could be introduced by applying town filter, which was found to be statistically significant in Section 3.2. Considerations:\n\nInteractive bubble plots of resale_price per sqm and remaining_lease_years\nDropdown menu to filter by town. Note that introduction of this filter not only helps users to visualise the different aspects of the bubble plot per town, but also reduces cluttering by too many datapoints.\nThe bubbles can be colored by flat_type and its size corresponds to the floor_area_sqm. The flat_type is chosen for color as it has the least number of categories, avoiding cluttering the plot with too many colors. The size corresponds to the floor_area_sqm to align with user’s intuition that bigger bubble means bigger size. While the resale price is already normalized against this, users can also see different angle given with remaining_lease_years in the x-axis. Note that with plot_ly, the color legend can also be selected/deselected to apply additional filter\nTo reduce cluttering further, opacity is introduced with white border\nTooltip indicating other important variables : resale_price_persqm, floor_area_sqm, remaining_lease_years, flat_model, and storey_range\n\n\n\nPreparation of visualisation\nFirstly, each unique instance of town was defined using for-loop. This will create a list within list (town_list) containing the method, args, and label arguments of each town. This list will be used as an input to buttons argument of the updatemenus. The annotation variables (annot) for the dropdown menu was also defined.\nRefer to code below for more details\n\ntown_list <- list()\nfor (i in 1:length(unique(flatpriceclean$town))) { \n  town_list[[i]] <- list(method = \"restyle\",\n                         args = list(\"transforms[0].value\",\n                                     unique(flatpriceclean$town)[i]),\n                         label = unique(flatpriceclean$town)[i])\n  }\n\nannot <- list(list(text = \"Planning Town:\",\n                   x = 1.41,\n                   y = 0.78,\n                   xref = 'paper',\n                   yref = 'paper',\n                   showarrow = FALSE))\n\n\n\n\n\n\n\nTip\n\n\n\nIt is useful to pre-define complicated list input to buttons argument of updatemenus outside the plot function. This will improve code readability drastically.\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that restyle is used in method argument as we want to modify data or data attributes and not the layout of the plot. Refer to here for additional information.\n\n\nplot_ly() is used to prepare the interactive bubble plot. Steps taken are\n\nflatpriceorder variable is created to ensure that there is no clash between the color and transforms argument in plot_ly.\nInitiating base scatterplot, indicated by type = 'scatter'. marker argument is used to introduce opacity and line (white plot border). Note that color and size arguments are specified to be flat_type and floor_area_sqm respectively.\nTooltip customisation is created using hovertemplate argument\ntransform argument is set to filter based on selected town provided in the updatemenus\nlayout argument is used to add plot title, x-axis title, and y-axis title. The range of the axis are also fixed to give users fixed reference frame.\nTo create the dropdown menu to select town, the updatemenus argument is used, passing the newly created variable town_list (see above) in the buttons argument. Note that the newly created variable annot (see above) is passed to annotations argument as well.\n\nRefer to code below for more details\n\n\nShow the code\nflatpriceorder <- flatpriceclean[order(flatpriceclean$flat_type), ]\n\n#Initiating the base plot\nplot_ly(data = flatpriceclean,\n        x = ~remaining_lease_years,\n        y = ~resale_price_persqm,\n        type = 'scatter',\n        mode = 'markers',\n        size = ~floor_area_sqm,\n        sizes = c(5, 15),\n        color = ~factor(flat_type),\n        marker = list(opacity = 0.6,\n                      sizemode = 'diameter',\n                      line = list(width = 0.2, color = '#FFFFFF')),\n        \n#Creating tooltip details\n        hovertemplate = ~paste(\"<br>Resale Price per sqm:\", resale_price_persqm,\n                               \"<br>Floor Area (sqm):\", floor_area_sqm,\n                               \"<br>Remaining Lease:\", remaining_lease_years,\n                               \"<br>Flat Model:\", flat_model,\n                               \"<br>Storey Height:\", storey_range),\n\n#Transform plotly by filtering the selected town in updatemenus       \n        transforms = list(list(type = 'filter',\n                               target = ~flatpriceorder$town,\n                               operation = '=',\n                               value = unique(flatpriceorder$town)[1])\n                          )\n        ) |> \n\n  \n#Configuring the plot and axis title and range  \n  layout(title = \"Resale Price per flat area increases with remaining lease \\nResale transactions by towns, 2022\",\n         xaxis = list(title = \"Remaining Lease (Year)\",\n                      range = c(40, 100)),\n         yaxis = list(title = \"Resale Price per sqm (SGD)\",\n                      range = c(3000, 16000)),\n         \n#Creating the dropdown box for users to filter using town\n         updatemenus = list(list(type = 'dropdown',\n                                 xref = \"paper\",\n                                 yref = \"paper\",\n                                 x = 1.4, y = 0.7,\n                                 buttons = town_list)\n                            ),\n         annotations = annot\n         )\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nChange the “planning town” dropdown box and discover interesting patterns between different towns\n\n\n\n\nInsights\nThis new plot is quite insightful as it allows users to understand the relationship between resale price and remaining lease and flat types by towns/estates. Interesting insights:\n\nThe fixed reference frame (x-axis and y-axis range) allows users to see the lower resale price in Woodlands vs higher resale price in Kallang\nOne can also discern how newer estates like Punggol fetch relatively low resale price (<8kSGD) per sqm despite having > 80 years remaining lease. This is in comparison with Central Area which can fetch up to 14kSGD per sqm for the same remaining lease. This highlights the importance of town centrality in resale price\nIn a more mature estates like Bedok, Toa Payoh, or Queenstown, the older flats tend to be predominantly dominated by 3-room flats, fetching lower resale price. Between 60-80 years remaining lease, they are dominated by 4 & 5-room flats. Interestingly, beyond 80 years remaining lease, there are significant numbers of 3-room flats sold fetching competitive price."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html",
    "title": "Hands-on Exercise 5: Ternary Plot",
    "section": "",
    "text": "The code chunk below uses p_load() of pacman package to check if packages are installed in the computer. If they are, then they will be launched into R. The R packages installed are:\n\nggtern, a ggplot extension specially designed to plot ternary diagrams. The package will be used to plot static ternary plots.\nPlotly R, an R package for creating interactive web-based graphs via plotly’s JavaScript graphing library, plotly.js . The plotly R libary contains the ggplotly function, which will convert ggplot2 figures into a Plotly object.\n\n\npacman::p_load(ggtern, plotly, tidyverse)\n\n\n\n\n\npop_data <- read_csv(\"data/respopagsex2000to2018_tidy.csv\") \n\n\n\n\n\nagpop_mutated <- pop_data %>%\n  mutate(`Year` = as.character(Year))%>%\n  spread(AG, Population) %>%\n  mutate(YOUNG = rowSums(.[4:8]))%>%\n  mutate(ACTIVE = rowSums(.[9:16]))  %>%\n  mutate(OLD = rowSums(.[17:21])) %>%\n  mutate(TOTAL = rowSums(.[22:24])) %>%\n  filter(Year == 2018)%>%\n  filter(TOTAL > 0)\n\nagpop_mutated\n\n# A tibble: 234 × 25\n   PA        SZ    Year  AGE0-…¹ AGE05…² AGE10…³ AGE15…⁴ AGE20…⁵ AGE25…⁶ AGE30…⁷\n   <chr>     <chr> <chr>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1 Ang Mo K… Ang … 2018      180     270     320     300     260     300     270\n 2 Ang Mo K… Chen… 2018     1060    1080    1080    1260    1400    1880    1940\n 3 Ang Mo K… Chon… 2018      900     900    1030    1220    1380    1760    1830\n 4 Ang Mo K… Kebu… 2018      720     850    1010    1120    1230    1460    1330\n 5 Ang Mo K… Semb… 2018      220     310     380     500     550     500     300\n 6 Ang Mo K… Shan… 2018      550     630     670     780     950    1080     990\n 7 Ang Mo K… Tago… 2018      260     340     430     500     640     690     440\n 8 Ang Mo K… Town… 2018      830     930     930     860    1020    1400    1350\n 9 Ang Mo K… Yio … 2018      160     160     220     260     350     340     230\n10 Ang Mo K… Yio … 2018      810    1070    1300    1450    1500    1590    1390\n# … with 224 more rows, 15 more variables: `AGE35-39` <dbl>, `AGE40-44` <dbl>,\n#   `AGE45-49` <dbl>, `AGE50-54` <dbl>, `AGE55-59` <dbl>, `AGE60-64` <dbl>,\n#   `AGE65-69` <dbl>, `AGE70-74` <dbl>, `AGE75-79` <dbl>, `AGE80-84` <dbl>,\n#   AGE85over <dbl>, YOUNG <dbl>, ACTIVE <dbl>, OLD <dbl>, TOTAL <dbl>, and\n#   abbreviated variable names ¹​`AGE0-4`, ²​`AGE05-9`, ³​`AGE10-14`, ⁴​`AGE15-19`,\n#   ⁵​`AGE20-24`, ⁶​`AGE25-29`, ⁷​`AGE30-34`\n\n\n\n\n\n\nggtern(data = agpop_mutated,\n       aes(x = YOUNG,\n           y = ACTIVE,\n           z = OLD)) +\n  geom_point() +\n  labs(title = \"Population structure, 2015\") +\n  theme_rgbw()\n\n\n\n\n\n\n\n\nlabel <- function(txt) {\n  list(\n    text = txt, \n    x = 0.1, y = 1,\n    ax = 0, ay = 0,\n    xref = \"paper\", yref = \"paper\", \n    align = \"center\",\n    font = list(family = \"serif\", size = 15, color = \"white\"),\n    bgcolor = \"#b3b3b3\", bordercolor = \"black\", borderwidth = 2\n  )\n}\n\naxis <- function(txt) {\n  list(\n    title = txt, tickformat = \".0%\", tickfont = list(size = 10)\n  )\n}\n\nternaryAxes <- list(\n  aaxis = axis(\"Young\"), \n  baxis = axis(\"Active\"), \n  caxis = axis(\"Old\")\n)\n\nplot_ly(\n  data = agpop_mutated, \n  a = ~YOUNG, \n  b = ~ACTIVE, \n  c = ~OLD, \n  color = I(\"black\"), \n  type = \"scatterternary\"\n) |> \n  layout(\n    annotations = label(\"Ternary Markers\"), \n    ternary = ternaryAxes\n  )"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05.1/Hands-on_Ex05.1.html",
    "href": "Hands-on_Ex/Hands-on_Ex05.1/Hands-on_Ex05.1.html",
    "title": "Hands-on Exercise 5: Visual Multivariate Analysis",
    "section": "",
    "text": "The code chunk below uses p_load() of pacman package to check if packages are installed in the computer. If they are, then they will be launched into R. The R packages installed are:\n\ncorrplot. A graphical display of a correlation matrix or general matrix. It also contains some algorithms to do matrix reordering. In addition, corrplot is good at details, including choosing color, text labels, color labels, layout, etc.\ncorrgram calculates correlation of variables and displays the results graphically. Included panel functions can display points, shading, ellipses, and correlation values with confidence intervals.\nheatmaply is an R package for building interactive cluster heatmap that can be shared online as a stand-alone HTML file\nggparcoord() of GGally package\nparallelPlotis an R package specially designed to plot a parallel coordinates plot by using ‘htmlwidgets’ package and d3.js\n\n\npacman::p_load(corrplot, ggstatsplot, seriation, dendextend, heatmaply, GGally, parallelPlot, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05.1/Hands-on_Ex05.1.html#visualising-correlation-matrices",
    "href": "Hands-on_Ex/Hands-on_Ex05.1/Hands-on_Ex05.1.html#visualising-correlation-matrices",
    "title": "Hands-on Exercise 5: Visual Multivariate Analysis",
    "section": "1. Visualising Correlation Matrices",
    "text": "1. Visualising Correlation Matrices\n\n1.1 Importing the data\n\nwine <- read_csv(\"data/wine_quality.csv\")\nwine\n\n# A tibble: 6,497 × 13\n   fixed…¹ volat…² citri…³ resid…⁴ chlor…⁵ free …⁶ total…⁷ density    pH sulph…⁸\n     <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <dbl>   <dbl>\n 1     7.4    0.7     0        1.9   0.076      11      34   0.998  3.51    0.56\n 2     7.8    0.88    0        2.6   0.098      25      67   0.997  3.2     0.68\n 3     7.8    0.76    0.04     2.3   0.092      15      54   0.997  3.26    0.65\n 4    11.2    0.28    0.56     1.9   0.075      17      60   0.998  3.16    0.58\n 5     7.4    0.7     0        1.9   0.076      11      34   0.998  3.51    0.56\n 6     7.4    0.66    0        1.8   0.075      13      40   0.998  3.51    0.56\n 7     7.9    0.6     0.06     1.6   0.069      15      59   0.996  3.3     0.46\n 8     7.3    0.65    0        1.2   0.065      15      21   0.995  3.39    0.47\n 9     7.8    0.58    0.02     2     0.073       9      18   0.997  3.36    0.57\n10     7.5    0.5     0.36     6.1   0.071      17     102   0.998  3.35    0.8 \n# … with 6,487 more rows, 3 more variables: alcohol <dbl>, quality <dbl>,\n#   type <chr>, and abbreviated variable names ¹​`fixed acidity`,\n#   ²​`volatile acidity`, ³​`citric acid`, ⁴​`residual sugar`, ⁵​chlorides,\n#   ⁶​`free sulfur dioxide`, ⁷​`total sulfur dioxide`, ⁸​sulphates\n\n\nColumn 1 to 11 are all numerical and continuous variables, while the last two are categorical\n\n\n1.2 Building with pairs() method\nSyntax description of pairs function\nPlotting the column 1 to 11. Note this can be adjusted to selected columns\n\npairs(wine[,1:11])\n\n\n\n\nSometimes we only want to show the upper or lower half of the correlation matrix as they are symmetric. Change the argument upper.panel = NULL to lower.panel = NULL to get the opposite impact.\n\npairs(wine[,2:12], upper.panel = NULL)\n\n\n\n\nShowing the correlation coefficient of each pair of variables using panel.cor function\n\n#|warning: false\npanel.cor <- function(x, y, digits = 2, prefix = \"\", cex.cor, ...) {\n  usr <- par(\"usr\")\n  on.exit(par(usr))\n  par(usr = c(0,1,0,1))\n  r <- abs(cor(x, y, use = \"complete.obs\"))\n  txt <- format(c(r, 0.123456789), digits = digits)[1]\n  txt <- paste(prefix, txt, sep=\"\")\n  if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)\n  text(0.5, 0.5, txt, cex = cex.cor * (1 + r)/2)\n}\n\npairs(wine[,2:12], upper.panel = panel.cor)\n\n\n\n\n\n\n1.3 Building with ggcormat() method\nVisualising correlation matrix by using ggcorrmat() of ggstatsplot package provides a comprehensive and yet professional statistical report.\n\nggstatsplot::ggcorrmat(\n  data = wine, \n  cor.vars = 1:11,\n  ggcorrplot.args = list(outline.color = \"black\", \n                         hc.order = TRUE,\n                         tl.cex = 10),\n  title    = \"Correlogram for wine dataset\",\n  subtitle = \"Four pairs are no significant at p < 0.05\"\n)\n\n\n\n\nggcorrplot.args argument provide additional (mostly aesthetic) arguments that will be passed to ggcorrplot::ggcorrplot function. The list should avoid any of the following arguments since they are already internally being used: corr, method, p.mat, sig.level, ggtheme, colors, lab, pch, legend.title, digits.\nThe sample sub-code chunk can be used to control specific component of the plot such as the font size of the x-axis, y-axis, and the statistical report.\n\nggplot.component = list(\n    theme(text=element_text(size=5),\n      axis.text.x = element_text(size = 8),\n      axis.text.y = element_text(size = 8)))\n\nBuilding multiple plots is possible using grouped_ggcorrmat() of ggstatsplot.\n\ngrouped_ggcorrmat(\n  data = wine,\n  cor.vars = 1:11,\n  grouping.var = type,        #to build facet plot\n  type = \"robust\",\n  p.adjust.method = \"holm\",\n  \n  #provides list of additional arguments\n  plotgrid.args = list(ncol = 2),       \n  ggcorrplot.args = list(outline.color = \"black\", \n                         hc.order = TRUE,\n                         tl.cex = 10),\n  \n  #calling plot annotations arguments of patchwork\n  annotation.args = list(               \n    tag_levels = \"a\",\n    title = \"Correlogram for wine dataset\",\n    subtitle = \"The measures are: alcohol, sulphates, fixed acidity, citric acid, chlorides, residual sugar, density, free sulfur dioxide and volatile acidity\",\n    caption = \"Dataset: UCI Machine Learning Repository\"\n  )\n)\n\n\n\n\n\n\n1.4 Building with corrplot package\nFull documentations on corrplot package - An Introduction to corrplot Package\nBefore we can plot a corrgram using corrplot(), we need to compute the correlation matrix of wine data frame.\n\nwine.cor <- cor(wine[, 1:11])\n\nNext, corrplot() is used to plot the corrgram by using all the default setting as shown in the code chunk below.\n\ncorrplot(wine.cor)\n\n\n\n\nFurther Customisation below.\nOther layout design argument such as tl.pos, tl.cex, tl.offset, cl.pos, cl.cex and cl.offset\n\ncorrplot(wine.cor, \n         method = \"ellipse\", \n         type=\"lower\",\n         diag = FALSE,      #turn off diagonal cells\n         tl.col = \"black\")  #change the axis text label color to black\n\n\n\n\nWe can design corrgram with mixed visual matrix of one half and numerical matrix on the other half. In order to create a coorgram with mixed layout, the corrplot.mixed(), a wrapped function for mixed visualisation style will be used.\n\ncorrplot.mixed(wine.cor, \n               lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",   #placement of the axis label\n               diag = \"l\",      #specify glyph on the principal diagonal\n               tl.col = \"black\")\n\n\n\n\nFigure below shows a corrgram combined with the significant test. The corrgram reveals that not all correlation pairs are statistically significant. For example the correlation between total sulfur dioxide and free surfur dioxide is statistically significant at significant level of 0.1 but not the pair between total sulfur dioxide and citric acid.\nWith corrplot package, we can use the cor.mtest() to compute the p-values and confidence interval for each pair of variables.\n\nwine.sig = cor.mtest(wine.cor, conf.level= .95)\n\n\ncorrplot(wine.cor,\n         method = \"number\",\n         type = \"lower\",\n         diag = FALSE,\n         tl.col = \"black\",\n         tl.srt = 45,\n         p.mat = wine.sig$p,  #input the calculated conf.level\n         sig.level = .05)\n\n\n\n\nMatrix reorder is very important for mining the hiden structure and pattern in a corrgram. By default, the order of attributes of a corrgram is sorted according to the correlation matrix (i.e. “original”). The default setting can be over-write by using the order argument of corrplot(). Currently, corrplot package support four sorting methods, they are:\n\n“AOE” is for the angular order of the eigenvectors. See Michael Friendly (2002) for details.\n“FPC” for the first principal component order.\n“hclust” for hierarchical clustering order, and “hclust.method” for the agglomeration method to be used.\n\n“hclust.method” should be one of “ward”, “single”, “complete”, “average”, “mcquitty”, “median” or “centroid”.\n\n“alphabet” for alphabetical order.\n\n\n#ordering using AOE\ncorrplot.mixed(wine.cor, \n               lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               order=\"AOE\",\n               tl.col = \"black\")\n\n\n\n\n\n#ordering using hierarchical clustering using ward\ncorrplot(wine.cor, \n         method = \"ellipse\", \n         tl.pos = \"lt\",\n         tl.col = \"black\",\n         order=\"hclust\",\n         hclust.method = \"ward.D\",\n         addrect = 3)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05.1/Hands-on_Ex05.1.html#heatmap-for-visualising-and-analysing-multivariate-data",
    "href": "Hands-on_Ex/Hands-on_Ex05.1/Hands-on_Ex05.1.html#heatmap-for-visualising-and-analysing-multivariate-data",
    "title": "Hands-on Exercise 5: Visual Multivariate Analysis",
    "section": "2. Heatmap for visualising and analysing multivariate data",
    "text": "2. Heatmap for visualising and analysing multivariate data\nHeatmaps are good for showing variance across multiple variables, revealing any patterns, displaying whether any variables are similar to each other, and for detecting if any correlations exist in-between them.\n\n2.1 Data import and preparation\n\nwh <- read_csv(\"data/WHData-2018.csv\")\n\n\nrow.names(wh) <- wh$Country\n\nTransforming the data frame into a matrix to make heatmap\n\nwh1 <- select(wh, c(3, 7:12))\nwh_matrix <- data.matrix(wh)\n\n\n\n2.2 Static heatmap\nUsing heatmap() of R stats package. It draws a simple heatmap which is not very informative as the variables are not normalized (i.e., happiness score values are higher than other variables).\n\nwh_heatmap <- heatmap(wh_matrix,\n                      #the Rowv and Colv below are to switch off the option of plotting the row and column dendograms (cluster)\n                      Rowv=NA, Colv=NA)\n\n\n\n\nNormalising using scale argument\n\nwh_heatmap <- heatmap(wh_matrix,\n                      scale=\"column\",\n                      \n                      #define font size for y-axis and x-axis labels\n                      cexRow = 0.6, \n                      cexCol = 0.8,\n                      \n                      #margins ensure entire x-axis labels are displayed completely\n                      margins = c(10, 4))\n\n\n\n\n\n\n2.3 Interactive heatmap\nheatmaply is an R package for building interactive cluster heatmap that can be shared online as a stand-alone HTML file. It is designed and maintained by Tal Galili.\nReview the Introduction to Heatmaply to have an overall understanding of the features and functions of Heatmaply package.\nUser manualof the package\nBasic heatmap using heatmaply, excluding column 1,2,4,5\n\nheatmaply(wh_matrix[, -c(1,2,4,5)])\n\n\n\n\n\n\nScaling method\n\nWhen all variables are came from or assumed to come from some normal distribution, then scaling (i.e.: subtract the mean and divide by the standard deviation) would bring them all close to the standard normal distribution.\nIn such a case, each value would reflect the distance from the mean in units of standard deviation.\nThe scale argument in heatmaply() supports column and row scaling.\n\n\nheatmaply(wh_matrix[, -c(1, 2, 4, 5)],\n          scale = \"column\")\n\n\n\n\n\n\n\nNormalising method\n\nWhen variables in the data comes from possibly different (and non-normal) distributions, the normalize function can be used to bring data to the 0 to 1 scale by subtracting the minimum and dividing by the maximum of all observations.\nThis preserves the shape of each variable’s distribution while making them easily comparable on the same “scale”.\n\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]))\n\n\n\n\n\n\n\nPercentising method\n\nThis is similar to ranking the variables, but instead of keeping the rank values, divide them by the maximal rank.\nThis is done by using the ecdf of the variables on their own values, bringing each value to its empirical percentile.\nThe benefit of the percentize function is that each value has a relatively clear interpretation, it is the percent of observations that got that value or below it.\n\n\nheatmaply(percentize(wh_matrix[, -c(1, 2, 4, 5)]))\n\n\n\n\n\n\n\nClustering\nManual approach\nIn the code chunk below, the heatmap is plotted by using hierachical clustering algorithm with “Euclidean distance” and “ward.D” method.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\")\n\n\n\n\n\nStatistical approach\nIn order to determine the best clustering method and number of cluster the dend_expend() and find_k() functions of dendextend package will be used.\nUse dend_expend() to determine the recommended clustering method with Euclidean distance\n\nwh_d <- dist(normalize(wh_matrix[, -c(1, 2, 4, 5)]), method = \"euclidean\")\ndend_expend(wh_d)[[3]]\n\n  dist_methods hclust_methods     optim\n1      unknown         ward.D 0.6137851\n2      unknown        ward.D2 0.6289186\n3      unknown         single 0.4774362\n4      unknown       complete 0.6434009\n5      unknown        average 0.6701688\n6      unknown       mcquitty 0.5020102\n7      unknown         median 0.5901833\n8      unknown       centroid 0.6338734\n\n\nThe output above shows that average method should be used as it gives the high optimum value.\nNext, find_k() is used to determine the optimal number of cluster. Figure below shows k = 3 is optimal\n\nwh_clust <- hclust(wh_d, method = \"average\")\nnum_k <- find_k(wh_clust)\nplot(num_k)\n\n\n\n\nUsing above results, plot using heatmaply()\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          dist_method = \"euclidean\",\n          hclust_method = \"average\",\n          k_row = 3)\n\n\n\n\n\nSeriation\nheatmaply uses the seriation package to find an optimal ordering of rows and columns. Optimal means to optimize the Hamiltonian path length that is restricted by the dendrogram structure. This, in other words, means to rotate the branches so that the sum of distances between each adjacent leaf (label) will be minimized. This is related to a restricted version of the travelling salesman problem.\nDifferent algorithms : Optimal Leaf Ordering (OLO), Gruvaeus and Wainer (GW), or “mean” which gives the output we would get by default from heatmap functions in other packages such as gplots::heatmap.2. The option “none” gives us the dendrograms without any rotation that is based on the data matrix. Example:\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"OLO\")\n\n\n\n\n\nPutting all together\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          Colv=NA,\n          seriate = \"none\",\n          colors = Blues,\n          \n          #cluster k = 5\n          k_row = 5,\n          \n          #change the top margin to 60 and row margin to 200\n          margins = c(NA,200,60,NA),\n          \n          #change fontsize for row and column labels\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main=\"World Happiness Score and Variables by Country, 2018 \\nDataTransformation using Normalise Method\",\n          xlab = \"World Happiness Indicators\",\n          ylab = \"World Countries\"\n          )"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05.1/Hands-on_Ex05.1.html#parallel-coordinates",
    "href": "Hands-on_Ex/Hands-on_Ex05.1/Hands-on_Ex05.1.html#parallel-coordinates",
    "title": "Hands-on Exercise 5: Visual Multivariate Analysis",
    "section": "3. Parallel Coordinates",
    "text": "3. Parallel Coordinates\nParallel coordinates plot is a data visualisation specially designed for visualising and analysing multivariate, numerical data. It is ideal for comparing multiple variables together and seeing the relationships between them.\nThe strength of parallel coordinates isn’t in their ability to communicate some truth in the data to others, but rather in their ability to bring meaningful multivariate patterns and comparisons to light when used interactively for analysis.\nParallel coordinates plot can be used to characterise clusters detected during customer segmentation.\n\n3.1 Static Parallel Coordinates Plot\nEnhance visualisation with boxplot\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           \n           #group observations using single variable (Region - column 2) and color\n           groupColumn = 2,\n           \n           #scale the variables using uniminmax method\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Parallel Coordinates Plot of World Happines Variables\")\n\n\n\n\nWorking with facet_wrap()\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           groupColumn = 2,\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of World Happines Variables by Region\") +\n  facet_wrap(~ Region) + \n  \n  #rotating the x-axis label to improve readability\n  theme(axis.text.x = element_text(angle = 30, hjust = 1))\n\n\n\n\n\n\n3.1 Interactive Parallel Coordinates Plot\nparallelPlot is an R package specially designed to plot a parallel coordinates plot by using ‘htmlwidgets’ package and d3.js.\n\nwh_i <- wh |> \n  select(\"Happiness score\", c(7:12))\n\n\nhisto <- rep(TRUE, ncol(wh_i))\n\nparallelPlot(wh_i,\n             continuousCS = \"YlOrRd\",\n             rotateTitle = TRUE,\n             histoVisibility = histo)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex05/In-class_Ex05.html",
    "href": "In-class_Ex/In-class_Ex05/In-class_Ex05.html",
    "title": "In-class Exercise 5",
    "section": "",
    "text": "1. Install and loading R packages\nPackages will be installed and loaded.\n\npacman::p_load(corrplot, ggstatsplot, heatmaply, GGally, parallelPlot, tidyverse)\n\n\n\n2. Importing Data\n\nwine <- read_csv(\"data/wine_quality.csv\")\nwine\n\n# A tibble: 6,497 × 13\n   fixed…¹ volat…² citri…³ resid…⁴ chlor…⁵ free …⁶ total…⁷ density    pH sulph…⁸\n     <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <dbl>   <dbl>\n 1     7.4    0.7     0        1.9   0.076      11      34   0.998  3.51    0.56\n 2     7.8    0.88    0        2.6   0.098      25      67   0.997  3.2     0.68\n 3     7.8    0.76    0.04     2.3   0.092      15      54   0.997  3.26    0.65\n 4    11.2    0.28    0.56     1.9   0.075      17      60   0.998  3.16    0.58\n 5     7.4    0.7     0        1.9   0.076      11      34   0.998  3.51    0.56\n 6     7.4    0.66    0        1.8   0.075      13      40   0.998  3.51    0.56\n 7     7.9    0.6     0.06     1.6   0.069      15      59   0.996  3.3     0.46\n 8     7.3    0.65    0        1.2   0.065      15      21   0.995  3.39    0.47\n 9     7.8    0.58    0.02     2     0.073       9      18   0.997  3.36    0.57\n10     7.5    0.5     0.36     6.1   0.071      17     102   0.998  3.35    0.8 \n# … with 6,487 more rows, 3 more variables: alcohol <dbl>, quality <dbl>,\n#   type <chr>, and abbreviated variable names ¹​`fixed acidity`,\n#   ²​`volatile acidity`, ³​`citric acid`, ⁴​`residual sugar`, ⁵​chlorides,\n#   ⁶​`free sulfur dioxide`, ⁷​`total sulfur dioxide`, ⁸​sulphates\n\n\n\npop_data <- read_csv(\"data/respopagsex2000to2018_tidy.csv\") \n\n\nwh <- read_csv(\"data/WHData-2018.csv\")\n\n\n\n3. Data Preparation\nData preparation for population data\n\nagpop_mutated <- pop_data %>%\n  mutate(`Year` = as.character(Year))%>%\n  spread(AG, Population) %>%\n  mutate(YOUNG = rowSums(.[4:8]))%>%\n  mutate(ACTIVE = rowSums(.[9:16]))  %>%\n  mutate(OLD = rowSums(.[17:21])) %>%\n  mutate(TOTAL = rowSums(.[22:24])) %>%\n  filter(Year == 2018)%>%\n  filter(TOTAL > 0)\n\nagpop_mutated\n\n# A tibble: 234 × 25\n   PA        SZ    Year  AGE0-…¹ AGE05…² AGE10…³ AGE15…⁴ AGE20…⁵ AGE25…⁶ AGE30…⁷\n   <chr>     <chr> <chr>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1 Ang Mo K… Ang … 2018      180     270     320     300     260     300     270\n 2 Ang Mo K… Chen… 2018     1060    1080    1080    1260    1400    1880    1940\n 3 Ang Mo K… Chon… 2018      900     900    1030    1220    1380    1760    1830\n 4 Ang Mo K… Kebu… 2018      720     850    1010    1120    1230    1460    1330\n 5 Ang Mo K… Semb… 2018      220     310     380     500     550     500     300\n 6 Ang Mo K… Shan… 2018      550     630     670     780     950    1080     990\n 7 Ang Mo K… Tago… 2018      260     340     430     500     640     690     440\n 8 Ang Mo K… Town… 2018      830     930     930     860    1020    1400    1350\n 9 Ang Mo K… Yio … 2018      160     160     220     260     350     340     230\n10 Ang Mo K… Yio … 2018      810    1070    1300    1450    1500    1590    1390\n# … with 224 more rows, 15 more variables: `AGE35-39` <dbl>, `AGE40-44` <dbl>,\n#   `AGE45-49` <dbl>, `AGE50-54` <dbl>, `AGE55-59` <dbl>, `AGE60-64` <dbl>,\n#   `AGE65-69` <dbl>, `AGE70-74` <dbl>, `AGE75-79` <dbl>, `AGE80-84` <dbl>,\n#   AGE85over <dbl>, YOUNG <dbl>, ACTIVE <dbl>, OLD <dbl>, TOTAL <dbl>, and\n#   abbreviated variable names ¹​`AGE0-4`, ²​`AGE05-9`, ³​`AGE10-14`, ⁴​`AGE15-19`,\n#   ⁵​`AGE20-24`, ⁶​`AGE25-29`, ⁷​`AGE30-34`\n\n\nData preparation for WHData. Transform the data into matrix. Note that wh_matrix is in matrix format.\nThis is required to plot the heatmap\n\n#change the country name to row number\nrow.names(wh) <- wh$Country\n\n#select the relevant columns to be selected in the matrix\nwh1 <- select(wh, c(3, 7:12))\nwh_matrix <- data.matrix(wh)\n\n\n\n4. Correlation Matrix\nCreating matrix from column 1 to 11 from wine dataset. Note that we should only use numerical data in the correlation matrix and not categorical data.\n\npairs(wine[,1:11])\n\n\n\n\nUsing ggcorrmat() to provide a comprehensive and yet professional statistical report.\n\n#|fig-width: 7\n#|fig-height: 7\nggstatsplot::ggcorrmat(\n  data = wine, \n  cor.vars = 1:11\n)\n\n\n\n\nWe can specify ggcorrplot.args as a list as below. Adding the title and subtitle as well\n\nggstatsplot::ggcorrmat(\n  data = wine, \n  cor.vars = 1:11,\n                         #change the color of the outlines\n  ggcorrplot.args = list(outline.color = \"red\", \n                         \n                         #order based on hierarchical clustering\n                         hc.order = TRUE,\n                         \n                         #change the cross smaller\n                         tl.cex = 10),\n  title    = \"Correlogram for wine dataset\",\n  subtitle = \"Four pairs are no significant at p < 0.05\"\n)\n\n\n\n\nCreating facet correlogram between red and white wine (grouping.var = type)\n\ngrouped_ggcorrmat(\n  data = wine,\n  cor.vars = 1:11,\n  grouping.var = type,        #to build facet plot\n  type = \"robust\",\n  p.adjust.method = \"holm\",\n  \n  #provides list of additional arguments\n  plotgrid.args = list(ncol = 2),       \n  ggcorrplot.args = list(outline.color = \"black\", \n                         hc.order = TRUE,\n                         tl.cex = 10),\n  \n  #calling plot annotations arguments of patchwork\n  annotation.args = list(               \n    tag_levels = \"a\",\n    title = \"Correlogram for wine dataset\",\n    subtitle = \"The measures are: alcohol, sulphates, fixed acidity, citric acid, chlorides, residual sugar, density, free sulfur dioxide and volatile acidity\",\n    caption = \"Dataset: UCI Machine Learning Repository\"\n  )\n)\n\n\n\n\nUsing corrplot() is used to build ordered correlation matrix (by hclust)\nNote: we need to compute correlation matrix of the wine data frame first\n\nwine.cor <- cor(wine[, 1:11])\n\n\n#ordering using hierarchical clustering using ward\ncorrplot(wine.cor, \n         method = \"ellipse\", \n         tl.pos = \"lt\",\n         tl.col = \"black\",\n         order=\"hclust\",\n         hclust.method = \"ward.D\",\n         addrect = 3)\n\n\n\n\nMixing corrgram and numerical matrix together using corrplot.mixed()\n\ncorrplot.mixed(wine.cor, \n               lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",   #placement of the axis label\n               diag = \"l\",      #specify glyph on the principal diagonal\n               tl.col = \"black\")\n\n\n\n\n\n\n5. Heatmap\nThis is mainly used for visualising hierarchical clustering.\nBasic interactive heatmap using heatmaply , excluding column 1,2,4,5\n\nheatmaply(wh_matrix[, -c(1,2,4,5)])\n\n\n\n\n\nData standardisation might be required by scaling (scale argument), normalising(normalize()), percentising(percentize()) to ensure the variable values are not so different. The clustering methods can also be customised\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\")\n\n\n\n\n\n\n\n6. Parallel Plot\nParallel coordinates plot is a data visualisation specially designed for visualising and analysing multivariate, numerical data. It is ideal for comparing multiple variables together and seeing the relationships between them.\n\nwh_i <- wh |> \n  select(\"Happiness score\", c(7:12))\n\n\nhisto <- rep(TRUE, ncol(wh_i))\n\nparallelPlot(wh_i,\n             continuousCS = \"YlOrRd\",\n             rotateTitle = TRUE,\n             histoVisibility = histo)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html",
    "title": "Hands-on Exercise 6: Time-Series Visualisation",
    "section": "",
    "text": "The code chunk below uses p_load() of pacman package to check if packages are installed in the computer. If they are, then they will be launched into R. The R packages installed are:\n\nlubridate package to work with date and time\n\n\npacman::p_load(scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-calendar-heatmap",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-calendar-heatmap",
    "title": "Hands-on Exercise 6: Time-Series Visualisation",
    "section": "2. Plotting Calendar Heatmap",
    "text": "2. Plotting Calendar Heatmap\n\n2.1 Importing the data\nFor the purpose of this hands-on exercise, eventlog.csv file will be used. This data file consists of 199,999 rows of time-series cyber attack records by country.\n\nattacks <- read_csv(\"data/eventlog.csv\")\n\nCheck data structure below\n\nkable(head(attacks))\n\n\n\n\ntimestamp\nsource_country\ntz\n\n\n\n\n2015-03-12 15:59:16\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:00:48\nFR\nEurope/Paris\n\n\n2015-03-12 16:02:26\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:02:38\nUS\nAmerica/Chicago\n\n\n2015-03-12 16:03:22\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:03:45\nCN\nAsia/Shanghai\n\n\n\n\n\n\n\n2.2 Data Wrangling\n\n2.2.1 Deriving weekday and hour of day fields\nBefore we can plot the calender heatmap, two new fields namely wkday and hour need to be derived. In this step, we will write a function to perform the task. We will use lubridate::ymd_hms() and lubridate::hour() to format the time. weekdays() is a base R function.\n\nmake_hr_wkday <- function(ts, sc, tz){\n  real_times <- ymd_hms(ts,\n                        tz = tz[1],\n                        quiet = TRUE)\n  dt <- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n}\n\n\n\n2.2.2 Deriving the attacks tibble data frame\nNote: Convert the wkday and hour fields into factor to ensure ordering\n\nwkday_levels <- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks <- attacks |> \n  group_by(tz) |> \n  \n  #call the function in Step 2.2.1\n  do(make_hr_wkday(.$timestamp,\n                   .$source_country,\n                   .$tz)) |> \n  \n  ungroup() |> \n  mutate(wkday = factor(wkday, levels = wkday_levels),\n         hour = factor(hour, levels = 0:23)\n  )\n\nVisualising the tidy tibble table after processing\n\nkable(head(attacks))\n\n\n\n\ntz\nsource_country\nwkday\nhour\n\n\n\n\nAfrica/Cairo\nBG\nSaturday\n20\n\n\nAfrica/Cairo\nTW\nSunday\n6\n\n\nAfrica/Cairo\nTW\nSunday\n8\n\n\nAfrica/Cairo\nCN\nSunday\n11\n\n\nAfrica/Cairo\nUS\nSunday\n15\n\n\nAfrica/Cairo\nCA\nMonday\n11\n\n\n\n\n\n\n\n\n2.3 Building Calendar Heatmap\n\n2.3.1 Basic calendar heatmap\n\n#Building grouped by aggregating attacks by wkday and hour fields. Using count(), new field called n is derived to calculate the frequency. na.omit() excludes the missing value\ngrouped <- attacks |> \n  count(wkday, hour) |> \n  ungroup() |> \n  na.omit()\n\nggplot(data = grouped,\n       aes(x = hour,\n           y = wkday,\n           fill = n)) +\n  \n  #plot the tiles (grids) at each x and y position, color and size arguments specify the border color and line size of the tiles\n  geom_tile(color = \"white\",\n            size = 0.1) +\n  \n  #remove border, axis lines, grids using theme_tufte\n  theme_tufte(base_family = \"serif\") +\n  \n  #ensure the plot has aspect ratio of 1:1\n  coord_equal() +\n  \n  #create gradient color scheme\n  scale_fill_gradient(name = '# of attacks',\n                      low = 'skyblue',\n                      high = 'darkblue') +\n  labs(x = NULL,\n       y = NULL,\n       title = \"Attacks by weekday and time of day\") +\n  \n  theme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n\n\n\n\n\n\n2.3.2 Multiple calendar heatmap by source_country\nStep 1: Identify top 4 countries with highest number of attacks\n\n#count the number of attacks by country\nattacks_by_country <- count(\n  attacks, source_country) |> \n  \n  #calculate the percent of attacks by country\n  mutate(percent = percent(n/sum(n))) |> \n  \n  #arrange it in descending order\n  arrange(desc(n))\n\nStep 2: Preparing the tidy data frame\n\n#select the top 4 countries in c() format\ntop4 <- attacks_by_country$source_country[1:4]\n\n\ntop4_attacks <- attacks |> \n  \n  #filter by top 4 countries\n  filter(source_country %in% top4) |> \n  \n  #group by source_country, wkday, hour and countr frequencies\n  count(source_country, wkday, hour) |> \n  ungroup() |> \n  \n  #convert source_country to factor with levels of top4\n  mutate(source_country = factor(\n    source_country, levels = top4)) |> \n  \n  #remove missing data\n  na.omit()\n\nStep 3: Plotting\n\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"serif\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-cycle-plot",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-cycle-plot",
    "title": "Hands-on Exercise 6: Time-Series Visualisation",
    "section": "3. Plotting Cycle Plot",
    "text": "3. Plotting Cycle Plot\n\n3.1 Importing the data\nFor the purpose of this hands-on exercise, arrivals_by_air.xlsx will be used.\n\nair <- read_excel(\"data/arrivals_by_air.xlsx\")\n\n\n\n3.2 Data Wrangling\n\n3.2.1 Deriving month and year fields\nCreate two new fields called month and year from Month-Year field\n\nair$month <- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year <- year(ymd(air$`Month-Year`))\n\n\n\n3.2.2 Select the target country\n\nVietnam <- air |> \n  select(Vietnam,\n         month,\n         year) |> \n  filter(year >= 2010)\n\n\n\n3.2.3 Compute year average arrivals by month\n\nhline.data <- Vietnam |> \n  group_by(month) |> \n  summarise(avgvalue = mean(Vietnam))\n\n\n\n\n3.3 Building Cycle Plot\n\nggplot() +\n  geom_line(data = Vietnam,\n            aes(x = year,\n                y = Vietnam,\n                group = month),\n            color = \"black\") +\n  geom_hline(aes(yintercept=avgvalue),\n             data = hline.data,\n             linetype = 6,\n             color = \"red\",\n             size = 0.5) +\n  facet_grid(~month) +\n  labs(axis.text.x = element_blank(),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex04/Take-home_Ex04.html",
    "href": "Take-home_Ex/Take-home_Ex04/Take-home_Ex04.html",
    "title": "Take-home Exercise 4",
    "section": "",
    "text": "This exercise aims to uncover the impact of COVID-19, global economic and political dynamic in 2022 on Singapore bi-lateral trade using time-series visualisation. The visualization is designed using ggplot2, its extensions, and tidyverse packages.\nThe original Merchandise Trade dataset was downloaded from Department of Statistics titled Merchandise Trade by Region/Market\nThe file downloaded was outputFile.xlsx\nThe study period is from for January 2020 to December 2022 period."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex04/Take-home_Ex04.html#data-preparation",
    "href": "Take-home_Ex/Take-home_Ex04/Take-home_Ex04.html#data-preparation",
    "title": "Take-home Exercise 4",
    "section": "2. Data Preparation",
    "text": "2. Data Preparation\n\n2.1 Install R packages and import dataset\nThe code chunk below uses pacman::p_load() to check if packages are installed. If they are, they will be launched into R. The packages installed are\n\nreadxl: Used to read data from excel files\nknitr: Used for dynamic report generation\nlubridate: Used to work with date and time\nggHoriPlot: Used to creating horizon plot\nggthemes: Provide additional themes for ggplot2\npatchwork: Used to combine plots\ndirectlabels: Add labels directly to plots\nggbraid: Used to create braided ribbons plot. remotes::install_github(\"nsgrantham/ggbraid\") is used to install the package.\nCGPfunctions: Contains newggslopegraph to plot slope graph\nggtext: Used to improve text rendering support for ggplot2\ngganimate: Used to create animated plot\nggifski: Makes smooth GIF animations for rendering of gganimate\nscales: Used to rescale and modify labels display\ntidyverse: A collection of core packages designed for data science, used extensively for data preparation and wrangling.\nAll packages can be found within CRAN, except for ggbraid.\n\n\n#Load packages\npacman::p_load(readxl, knitr, lubridate, ggHoriPlot, ggthemes, patchwork, directlabels, ggbraid, CGPfunctions, ggtext, gganimate, gifski, scales, tidyverse)\n\nImport data from excel file using readxl::read_excel() and store it in tibble sgimport and sgexport.\nNote that by choosing the specific range, the period of interest (January 2020 to December 2022) is manually selected.\n\n\n\n\n\n\nWarning\n\n\n\nUpon inspection of the excel file, it is noted that sgexport rows are smaller than sgimport, extending to row 101 instead of 129.\n\n\n\n#Import data\nsgimport <- read_excel(\"data/outputFile.xlsx\", sheet = \"T1\", range = \"A10:AK129\" )\n\nsgexport <- read_excel(\"data/outputFile.xlsx\", sheet = \"T2\", range = \"A10:AK101\" )\n\nAdditional data is downloaded from World Bank dataset which lists countries by world regions.\nImport data from excel file using readr::read_csv() and store it in tibble regions.\nThis Entity and World_RegionbyWorld_Bank variable is renamed to Countries and Region for easier interpretation and future joins with other tibble.\n\nregions <- read_csv(\"data/world-regions-according-to-the-world-bank.csv\", show_col_types = FALSE) |> \n  \n  rename(Countries = Entity,\n         Region = World_RegionbyWorld_Bank) |> \n  select(Countries, Region)\n\n\n\n\n\n\n2.2 Data cleaning\nScope of the study is to understand bi-lateral trade of Singapore with countries / trade partners around the world. Hence, we will not include regions (i.e., Asia, Africa) or collection of countries (i.e., European Union or Other Countries In Oceania).\n\n2.2.1 Cleaning the countries data for sgimport and sgexport\nLooking at the sgimport tibble below, we notice few problems\n\nThe layout of the tibble is not apt for time series. Ideally the time period needs to be in rows with the countries in column\nThe column names are in string format and needs to be converted to datetime format\nData Series contain not only countries/trade partners, but also regions or collection of countries\nThe countries name contain string suffix ‘(Thousand Dollars)’ and the values are in (’000) format\n\n\n\n\n\n\n\nNote\n\n\n\nSimilar issue is also observed with sgexport\n\n\n\nkable(head(sgimport))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData Series\n2022 Dec\n2022 Nov\n2022 Oct\n2022 Sep\n2022 Aug\n2022 Jul\n2022 Jun\n2022 May\n2022 Apr\n2022 Mar\n2022 Feb\n2022 Jan\n2021 Dec\n2021 Nov\n2021 Oct\n2021 Sep\n2021 Aug\n2021 Jul\n2021 Jun\n2021 May\n2021 Apr\n2021 Mar\n2021 Feb\n2021 Jan\n2020 Dec\n2020 Nov\n2020 Oct\n2020 Sep\n2020 Aug\n2020 Jul\n2020 Jun\n2020 May\n2020 Apr\n2020 Mar\n2020 Feb\n2020 Jan\n\n\n\n\nTotal Merchandise Imports (Thousand Dollars)\n49869770.0\n50653907.0\n53182943.0\n55799312.0\n58466009.0\n61029374.0\n59649162.0\n57604263.0\n56116002.0\n58079982.0\n44958373.0\n50026788.0\n54349357.0\n50674908.0\n47945213.0\n45980374.0\n44714491.0\n46107788.0\n45039845.0\n41559697.0\n45169547.0\n47668437.0\n37643664.0\n39028616.0\n40154550.0\n38477878.0\n38173829.0\n38801413.0\n36472279.0\n37843646.0\n35120892.0\n31458238.0\n35878828.0\n40433029.0\n39472637.0\n41180224.0\n\n\nAmerica (Million Dollars)\n6901.5\n7529.4\n7666.4\n7995.9\n8633.8\n7879.7\n8024.0\n8521.1\n7822.1\n7176.1\n5385.2\n5850.9\n6261.1\n6127.4\n6027.6\n5631.6\n5750.1\n5728.6\n5457.4\n5191.8\n6195.9\n5303.5\n4164.2\n4580.0\n4676.4\n4588.2\n4869.7\n4886.4\n4132.0\n4667.3\n4686.2\n4259.0\n5183.5\n5910.8\n5314.1\n5844.1\n\n\nAsia (Million Dollars)\n33611.7\n34733.7\n36120.9\n37696.3\n40911.9\n43214.2\n42507.2\n40534.7\n38735.7\n42199.9\n31611.3\n35014.0\n39140.3\n35949.6\n33552.7\n32533.4\n31492.5\n31645.0\n31021.0\n28497.2\n30623.1\n31367.8\n26122.6\n27413.7\n28200.4\n25844.9\n26127.9\n27823.2\n26052.3\n26767.4\n24779.3\n21718.9\n24534.5\n26783.6\n26588.1\n27128.1\n\n\nEurope (Million Dollars)\n7541.8\n7242.8\n7475.9\n8167.6\n7433.2\n8300.5\n7300.2\n7030.8\n7407.2\n7203.2\n6479.0\n7821.6\n7586.3\n6872.0\n6714.8\n6882.1\n5919.4\n6919.2\n7011.2\n6563.5\n6740.5\n8964.0\n5403.7\n5749.6\n6087.4\n6133.5\n6285.4\n5316.9\n5225.0\n5475.3\n4960.7\n4629.0\n5150.6\n6333.3\n6209.6\n6859.7\n\n\nOceania (Million Dollars)\n1399.9\n664.4\n1329.8\n1544.6\n935.9\n1060.6\n1141.8\n1164.7\n1559.1\n863.9\n814.4\n810.4\n744.8\n994.1\n1021.2\n599.8\n744.0\n1201.2\n890.1\n1001.7\n1030.5\n1131.0\n1134.7\n705.5\n540.9\n1412.8\n577.3\n477.7\n586.5\n493.1\n456.4\n441.8\n637.6\n845.9\n694.7\n819.7\n\n\nAfrica (Million Dollars)\n414.9\n483.6\n589.9\n395.0\n551.2\n574.4\n675.9\n352.9\n591.9\n636.9\n668.5\n529.9\n616.8\n731.8\n628.8\n333.4\n808.4\n613.8\n660.2\n305.4\n579.6\n902.2\n818.5\n579.9\n649.4\n498.6\n313.5\n297.2\n476.5\n440.6\n238.2\n409.6\n372.6\n559.4\n666.1\n528.6\n\n\n\n\n\nBefore doing any pivoting, each individual tibble needs to be tidied up to avoid further complications. The code chunks below perform the required data wrangling to\n\nRemove the regions or collection of countries in Data Series variable by filtering the first 7 rows out. This is done using dplyr::filter()\nRemove the string ‘(Thousand Dollars)’ from each of the countries’ name in . This is done using str_remove() function in combination with regular expression \" \\\\(Thousand Dollars\\\\)\". Assign this to new variable Countries using dplyr::mutate()\n\n\n\n\n\n\nImportant\n\n\n\nIn the next section, we will multiply the values by 1000 to compensate for the loss of string suffix ‘(Thousand Dollars)’\n\n\nRemove the old Data Series column\n\nThe modified tibbles are stored in new tibbles sgimport_ctry and sgexport_ctry respectively\n\nsgimport_ctry <- sgimport |> \n  \n  #remove the first 7 rows, which are Total and non-countries\n  filter(!row_number() %in% c(1:7)) |> \n  \n  #remove the '(Thousand Dollars)' string from column Data Series and call it Countries\n  mutate(Countries = str_remove(`Data Series`, \n                                \" \\\\(Thousand Dollars\\\\)\"), \n         .after = `Data Series`) |> \n  \n  #remove 'Data Series' column\n  select(-`Data Series`) \n\n\nsgexport_ctry <- sgexport |> \n  \n  #remove the first 7 rows, which are Total and non-countries\n  filter(!row_number() %in% c(1:7)) |> \n  \n  #remove the '(Thousand Dollars)' string from column Data Series and call it Countries\n  mutate(Countries = str_remove(`Data Series`, \n                                \" \\\\(Thousand Dollars\\\\)\"), \n         .after = `Data Series`) |> \n  \n  #remove 'Data Series' column\n  select(-`Data Series`) \n\n\n\n2.2.2 Pivot and transform tibbles to time-series layout\nTransforming sgimport_ctry and sgexport_ctry to time-series layout requires the help of tidyr::pivot_longer(), splitting the column string (i.e., ‘2022 Dec’) to Year and Month variables respectively. To do this, we will use the names_sep argument. The values are assigned to new variable Import_SGD and Export_SGD respectively.\nAdditionally, dplyr::mutate() will be used to\n\nConvert Month to factors, levelled based on the abbreviation (i.e., ‘Jan’). This will allow easy ordering during plotting\nConvert Year to integer for the same purpose as month\nCreate new variable Month_Year which is in datetime format to allow time-series plotting. This is done using lubridate::make_date() function\nMultiply the Import_SGD and Export_SGD values by 1000 to compensate for the loss of string suffix ‘(Thousand Dollars)’\n\nThe modified tibbles are stored in new tibbles sgimport_cln and sgexport_cln respectively\nSee the resulting tibble below; only sgimport_cln is shown for illustrative purpose as similar treatment is done on sgexport_cln.\n\nsgimport_cln <- sgimport_ctry |> \n  \n  #pivot_longer to get year and month timeseries\n  pivot_longer(cols = !Countries,\n               names_to = c(\"Year\", \"Month\"),\n               names_sep = \" \",\n               values_to = \"Import_SGD\"\n               ) |> \n  \n  #Convert Month to factors and Years to integers for ordering purposes\n  mutate(Month = factor(Month, levels = month.abb),\n         Year = as.integer(Year),\n         Month_Year = make_date(Year, Month),\n         .before = 1) |> \n  \n  #Multiply values by 1000\n  mutate(Import_SGD = Import_SGD*1000) \n\nsgimport_cln\n\n# A tibble: 4,032 × 5\n   Month_Year Countries  Year Month Import_SGD\n   <date>     <chr>     <int> <fct>      <dbl>\n 1 2022-12-01 Belgium    2022 Dec    103655000\n 2 2022-11-01 Belgium    2022 Nov    121773000\n 3 2022-10-01 Belgium    2022 Oct     88796000\n 4 2022-09-01 Belgium    2022 Sep    215978000\n 5 2022-08-01 Belgium    2022 Aug    132917000\n 6 2022-07-01 Belgium    2022 Jul    224676000\n 7 2022-06-01 Belgium    2022 Jun    114704000\n 8 2022-05-01 Belgium    2022 May    116817000\n 9 2022-04-01 Belgium    2022 Apr    146603000\n10 2022-03-01 Belgium    2022 Mar    319393000\n# … with 4,022 more rows\n\n\n\nsgexport_cln <- sgexport_ctry |> \n  \n  #pivot_longer to get year and month timeseries\n  pivot_longer(cols = !Countries,\n               names_to = c(\"Year\", \"Month\"),\n               names_sep = \" \",\n               values_to = \"Export_SGD\"\n               ) |> \n  \n  #Convert Month and Year to factors for ordering purposes\n  #Multiply values by 1000\n  mutate(Month = factor(Month, levels = month.abb),\n         Year = as.integer(Year),\n         Month_Year = make_date(Year, Month),\n         .before = 1) |> \n  \n  mutate(Export_SGD = Export_SGD*1000) \n\n\n\n2.2.3 Finding the discrepancies between sgimport_cln and sgexport_cln\nBefore joining the two tibbles: sgimport_cln and sgexport_cln, it is important to recognise that their number of rows are not the same. To detect the difference, a tibble called import_vs_export is created below to list the countries which appear in sgimport_cln but not in sgexport_cln.\n\nimport_vs_export <- setdiff(sgimport_ctry$Countries, sgexport_ctry$Countries) |> \n  enframe(name = NULL, value = \"diff\") |> \n  arrange(diff)\n\nimport_vs_export  |> \n  kable(caption = \"Countries in sgimport_cln that is not in sgexport_cln\",\n               row.names = TRUE)\n\n\nCountries in sgimport_cln that is not in sgexport_cln\n\n\n\ndiff\n\n\n\n\n1\nAnguilla\n\n\n2\nBahamas\n\n\n3\nBermuda\n\n\n4\nCocos (Keeling) Islands\n\n\n5\nCommonwealth Of Independent States\n\n\n6\nCook Islands\n\n\n7\nFrench Guiana\n\n\n8\nFrench Southern Territories\n\n\n9\nGrenada\n\n\n10\nGuatemala\n\n\n11\nHonduras\n\n\n12\nJamaica\n\n\n13\nKiribati\n\n\n14\nLiechtenstein\n\n\n15\nMicronesia\n\n\n16\nNauru\n\n\n17\nNetherlands Antilles\n\n\n18\nNiue\n\n\n19\nNorfolk Island\n\n\n20\nNorway\n\n\n21\nOther Countries In America\n\n\n22\nPalau\n\n\n23\nPanama\n\n\n24\nSouth Sudan\n\n\n25\nSt Vincent & The Grenadines\n\n\n26\nTrinidad & Tobago\n\n\n27\nTuvalu\n\n\n28\nWallis & Fatuna Islands\n\n\n\n\n\nReferring to above list, there are 28 countries with available import data, but has no export data.\n\n\n\n\n\n\nWarning\n\n\n\nWe cannot assume that the exports are zero, just because there is no available data.\n\n\n\n\n2.2.4 Joining the two tibbles and calculate trade balance and volume\ndplyr::left_join() function is used to join sgimport_cln and sgexport_cln. This is especially useful to avoid since sgimport_cln has more rows than sgexport_cln.\n\n\n\n\n\n\nTip\n\n\n\nleft_join() takes all the values from the first tibble, and looks for matches in the second tibble. If it finds a match, it adds the data from the second table; if not, it adds missing values.\n\n\nCountries with missing values in Export_SGD variable created by left_join() function will be excluded from analysis. As highlighted above, we cannot assume that the exports are zero, just because there is no available data. This is to avoid incomplete data when analysing trade balances. To remove this, import_vs_export tibble created above will be used to filter out the countries using dplyr::filter().\nBeside the countries in import_vs_export, it is noted that the import and export values of “Germany, Democratic Republic Of” are zeroes. This is referring to East Germany, a state that no longer exists since German reunification in 1990. This country is in the tibble as the original dataset tracks Singapore import/export data from 1976. Given the scope of the study from January 2020 onward, we will filter out this country as well using dplyr::filter().\nNote that “Other Countries In Oceania” is also removed as it is a collection of countries.\nAdditional data cleaning required :\n\nShortening the names of some countries like “Germany, Federal Republic Of”, “Vietnam, Socialist Republic Of”, and “Republic Of Korea”. dplyr::mutate() is used in conjunction with case_when()\nCreate new variable Trade_Balance_SGD subtracts Import_SGD from Export_SGD to indicate whether there is trade surplus or deficit from Singapore point-of-view\nCreate new variable Trade_Volume_SGD sums Export_SGD with Import_SGD as indication of total trade activities\n\n\nsgtrade_cln <- sgimport_cln |> \n  \n  #join sgimport_cln with sgexport_cln\n  left_join(sgexport_cln, by = c('Countries' = 'Countries', 'Month_Year' = 'Month_Year', 'Month' = 'Month', 'Year' = 'Year')) |> \n  \n    #remove countries with non-available export data\n  filter(!Countries %in% c(import_vs_export$diff, \"Germany, Democratic Republic Of\", \"Other Countries In Oceania\")) |> \n  \n  mutate(Countries = case_when(Countries == \"Germany, Federal Republic Of\" ~ \"Germany\",\n                               Countries == \"Vietnam, Socialist Republic Of\" ~ \"Vietnam\",\n                               Countries == \"Republic Of Korea\" ~ \"South Korea\",\n                               TRUE ~ Countries)) |> \n  \n  #Calculate trade balance\n  mutate(Trade_Balance_SGD = Export_SGD - Import_SGD,\n         Trade_Volumes_SGD = Export_SGD + Import_SGD) \n\nkable(head(sgtrade_cln))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMonth_Year\nCountries\nYear\nMonth\nImport_SGD\nExport_SGD\nTrade_Balance_SGD\nTrade_Volumes_SGD\n\n\n\n\n2022-12-01\nBelgium\n2022\nDec\n103655000\n432376000\n328721000\n536031000\n\n\n2022-11-01\nBelgium\n2022\nNov\n121773000\n756814000\n635041000\n878587000\n\n\n2022-10-01\nBelgium\n2022\nOct\n88796000\n350565000\n261769000\n439361000\n\n\n2022-09-01\nBelgium\n2022\nSep\n215978000\n386724000\n170746000\n602702000\n\n\n2022-08-01\nBelgium\n2022\nAug\n132917000\n570824000\n437907000\n703741000\n\n\n2022-07-01\nBelgium\n2022\nJul\n224676000\n991586000\n766910000\n1216262000\n\n\n\n\n\n\n\n2.2.5 Finding top countries by trade volume\nNot all countries trade equally with Singapore. Despite performing the extensive data cleaning in the previous sections, there are still 82 countries in the tibble.\n\nn_distinct(sgtrade_cln$Countries)\n\n[1] 82\n\n\nIn order to limit the scope of the study further, it is desired to calculate the each country trade volume and percentage of total trade volume. This will provide basis to filter out countries that contributed less than 0.05% of total trade volumes to Singapore.\nThe code chunk below performs:\n\nGroup sgtrade_cln by Countries and calculate each country’s Total_Trade_Volumes_SGD using dplyr::summarise() function\nCalculate Pct_Total_Trade_Volumes by dividing each country’s Total_Trade_Volumes_SGD with the sum(Total_Trade_Volumes_SGD) using dplyr::mutate() function\nArrange the countries by Pct_Total_Trade_Volumes in descending order and showcase the data\n\n\nsgtrade_top_ctry <- sgtrade_cln |> \n  \n  #Group by Countries and calculated Total Trade Volumes of Singapore\n  group_by(Countries) |> \n  summarise(Total_Trade_Volumes_SGD = sum(Trade_Volumes_SGD)) |> \n  \n  #Calculate the percentage of trade volume each country contributes to Singapore Total\n  mutate(Pct_Total_Trade_Volumes = round(Total_Trade_Volumes_SGD*100/sum(Total_Trade_Volumes_SGD), digits = 1)) |> \n  ungroup() |> \n  \n  #Arrange the countries based on the percentage\n  arrange(desc(Pct_Total_Trade_Volumes))\n\nkable(head(sgtrade_top_ctry))\n\n\n\n\nCountries\nTotal_Trade_Volumes_SGD\nPct_Total_Trade_Volumes\n\n\n\n\nMainland China\n475482628000\n14.1\n\n\nMalaysia\n385151258000\n11.4\n\n\nUnited States\n340907625000\n10.1\n\n\nTaiwan\n289258502000\n8.6\n\n\nHong Kong\n237874786000\n7.1\n\n\nIndonesia\n184262941000\n5.5\n\n\n\n\n\nNext, we will filter out countries that contribute less that 0.05% of Singapore total trade using dplyr::filter() function from sgtrade_cln.\n\n\n\n\n\n\nTip\n\n\n\nThe newly created variables : Total_Trade_Volumes_SGD and Pct_Total_Trade_Volumes might be useful for future plots, hence dplyr::left_join() function is again used.\n\n\nBy doing this, the number of countries are reduced to 52\n\n#Filter out the Countries with Pct_Total_Trade_Volumes < 0.05%\ntop0.05 <- sgtrade_top_ctry |> \n  filter(Pct_Total_Trade_Volumes > 0.05)\n\nsgtrade_cln <- sgtrade_cln |> \n  filter(Countries %in% top0.05$Countries) |> \n  \n#include the Total_Trade_Volumes_SGD and Pct_Total_Trade_Volumes in sgtrade_cln\n  left_join(top0.05, by = c('Countries' = 'Countries'))\n\n#finding out the number of distinct countries left\nn_distinct(sgtrade_cln$Countries)\n\n[1] 52"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex04/Take-home_Ex04.html#visualisation",
    "href": "Take-home_Ex/Take-home_Ex04/Take-home_Ex04.html#visualisation",
    "title": "Take-home Exercise 4",
    "section": "3. Visualisation",
    "text": "3. Visualisation\n\n3.1 Exploratory Data Visualisation\nThe plots in this section offer a high-level overview of Singapore’s bilateral merchandise trade performance amid Covid-19 recovery, with the aim of identifying general trends through exploratory analysis. Rather than providing detailed analyses for each country, the focus is on identifying broad patterns and relationships. This approach enables the identification of countries of interest, providing context for more focused analyses in the following section.\n\n3.1.1 Overall Singapore Trade Balance Performance\nTo gain an understanding of import and export trends in Singapore, we will begin with a simple time-series chart covering the period from January 2020 to December 2022.\n\n3.1.1.1 Design Consideration\nInstead of using simple line charts, braided ribbon chart is used with the following considerations:\n\nBraided ribbon charts helps to visualise the areas between import and export values, highlighting Singapore trade balance\nReference line will be provided, representing the average import and export values in 2020, which was a year marked by worldwide lockdowns and reduced economic activity due to the Covid-19 pandemic. This time period has been chosen as a relevant benchmark for understanding the impact of the pandemic on import and export trends.\nAnnotations explaining the events around the world\n\n\n\n\n\n\n\nTip\n\n\n\nSome details in the plot can help to enhance the visual aesthetics, such as:\n\nUsing diverging colorblind friendly palette\nDisplay the values in Billions SGD rather than the raw values\nUsing arrows to aid annotations\nClear intent in title, highlighting the story\nLabel the lines instead of using legend\n\n\n\n\n\n3.1.1.2 Preparation of visualisation\n\nData preparation\nThree tibbles are created for the following purpose:\n\ntotalsgtrade contains the total import and export values by time, irrespective of countries.\nThis is created by grouping sgtrade_cln data by Month_Year and Year variables and calculate the total Singapore Import and Export values, irrespective of countries. dplyr::group_by() and dplyr::summarise() functions are used.\ntotalsgtrade_long collapses the Import and Export columns to new variable Type. This is used for geom_line to allow plotting different lines and grouped them by color. tidyr::pivot_longer() is used to do this.\navg_total_2020 creates 1x3 tibble containing the overall average 2020 Singapore import and export values to draw the reference lines. Firstly totalsgtrade is filtered for Year == 2020. It is then grouped and summarised by mean of Import and Export.\n\n\n\nShow the code\n#Creating new tibbles to be used for geom_line and geom_braid respectively\ntotalsgtrade <- sgtrade_cln |> \n  group_by(Month_Year, Year) |> \n  summarise(Import = sum(Import_SGD),\n            Export = sum(Export_SGD))\n\ntotalsgtrade_long <- totalsgtrade |> \n  pivot_longer(cols = !c(Month_Year, Year),\n               names_to = \"Type\",\n               values_to = \"Values\")\n\navg_total_2020 <- totalsgtrade |> \n  filter(Year == 2020) |> \n  group_by (Year) |> \n  summarise(import = mean(Import),\n            export = mean(Export))\n\n\n\n\nPlotting the main graph\nSteps used to create the plots:\n\nBase plot is created using ggplot2::geom_line and ggbraid::geom_braid\n\n\n\n\n\n\nNote\n\n\n\nNote that totalsgtrade_long is used in geom_line to allow grouping the Type (Import or Export) by color and totalsgtrade is used in geom_braid. The fill argument of geom_braid is specified as Import<Export as Trade Surplus happens when Import < Export, and alpha specified as 0.5 to provide a degree of opacity.\n\n\nRemove the legend using ggplot2::guides() and add the labels at the end of each line using directlabels:geom_dl(). Note the method argument specifies gap between the label and the line\nPlotting the reference line using ggplot2::geom_hline. The linetype argument is specified as \"dashed\" to create dashed reference line. Add text on each reference line to indicate “Average 2020” using ggplot2::annotate()\nSet the colors of the line and ribbons using scale_color_manual() and scale_color_fill()\n\n\n\n\n\n\nTip\n\n\n\nThe color choice for colorblind-friendly is based on this article\n\n\nAs the x-axis is datetime, scale_x_date() needs to be used, indicating the limits of plots, date_breaks, and date_labels format. It is good to set the limit on the first time frame (January 2020) to remove gap on the left-hand side of the graph, hence expand argument is specified as c(0,0)\nIn order to convert the y-axis in terms of Billions SGD, we need to specify it in the labels argument of scale_y_continuous\nSet the theme and add titles, subtitles, and captions using theme() and labs() functions\n\n\n\nShow the code\n#Plotting the base plot\nbr_plot <- ggplot() +\n  geom_line(data = totalsgtrade_long,\n            aes(x = Month_Year,\n                y = Values,\n                group = Type,\n                color = Type),\n            linewidth = 1.2) +\n  \n  geom_braid(data = totalsgtrade,\n             aes(x = Month_Year,\n                 ymin = Import,\n                 ymax = Export,\n                 fill = Import < Export),\n             alpha = 0.5) +\n\n#Remove the legend \n  guides(linetype = \"none\", fill = \"none\") +\n  \n#Adding the 'Import' and 'Export' labels at the end of the line charts\n  geom_dl(data = totalsgtrade_long,\n          aes(x = Month_Year,\n              y = Values,\n              label = Type,\n              color = Type),\n          method = list(dl.trans(x = x + 0.2), \"last.points\", cex = 1)) +\n  \n  geom_dl(data = totalsgtrade_long,\n          aes(x = Month_Year,\n              y = Values,\n              label = Type,\n              color = Type),\n          method = list(dl.trans(x = x - 0.2), \"first.points\", cex = 1)) +\n  \n#Plotting the reference lines with annotations\n  geom_hline(aes(yintercept = avg_total_2020$export), \n             col=\"#0072B2\", \n             linewidth=0.8,\n             linetype = \"dashed\") +\n  \n  annotate(geom = \"text\", \n           x=as.Date(\"2022-12-01\"), \n           y=42000000000, \n           label=\"Avg 2020 Export\", \n           size=4, \n           color=\"#0072B2\") +\n  \n  geom_hline(aes(yintercept = avg_total_2020$import), \n             col=\"#D55E00\", \n             linewidth=0.8,\n             linetype = \"dashed\") +\n  \n  annotate(geom = \"text\", \n           x=as.Date(\"2022-12-01\"), \n           y=37500000000, \n           label=\"Avg 2020 Import\", \n           size=4, \n           color=\"#D55E00\") +\n\n#Setting the colors for the main plot  \n  scale_color_manual(values = c(\"#0072B2\", \"#D55E00\"),\n                     labels = c(\"Export\", \"Import\"),\n                     name = NULL,\n                     guide = \"none\") +\n  \n  scale_fill_manual(values = c(\"#E69F00\", \"#56B4E9\")) +\n  \n#Adjusting the scale\n  scale_x_date(expand = c(0,0),\n               limits = c(as.Date(\"2020-01-01\"),as.Date(\"2023-03-01\")),\n               date_breaks = \"6 month\",\n               date_labels = \"%b %Y\") +\n  \n  scale_y_continuous(\"Trade Values\",\n                     labels = function(x){paste0('$', abs(x/1000000000),'B')}) +\n  \n#Setting the theme\n  cowplot::theme_cowplot() +\n  \n  theme(axis.title.x = element_blank(),\n        legend.position = 'top',\n        legend.justification = 'center',\n        panel.grid.major.y = element_line(color = \"grey90\", linetype = \"solid\")) +\n  \n#Adding title, subtitle, and captions   \n  labs(title = \"Since early 2021, Singapore's trade activities were recovering from Covid-19\\nbut slowed down in mid-2022\",\n         subtitle = \"Total Merchandise Export and Import Trade Value of Singapore (in SGD), 2020-2022\",\n         caption = \"Merchandise Trade by Region/Market from Department of Statistics, Singapore\")\n\nbr_plot\n\n\n\n\n\n\n\n\n3.1.1.3 Insights\n\nOverall, Singapore maintains trade surplus throughout the duration, except for brief period in May 2022\nIn March 2020, both Singapore import and export fell further, coinciding with announcement of further Covid-19 restrictions (i.e., circuit breaker)\nWith gradual reopening of economy (i.e., Phase 3 reopening) in Dec 2020 to February 2021, trade seems to rebound back above the 2020 average. Throughout 2021, both import and export continues to rise\nSudden dip observed around February 2022, coinciding with the start of Russia-Ukraine War\nTrade surplus seems to be thinning in 2022, but activities remain high, reaching its peak in August/September 2022\nGradual decline of trade happens after the 3-year peak marking recession headwinds post Q3 2022\n\nWith interesting insights observed above, it makes sense to include them in the plot as well. Hence annotate() functions are used to add the text label and arrows. Refer to code below for more details.\n\n\nShow the code\n#Add relevant annotations   \nbr_plot + annotate(geom = \"label\",\n           x = as.Date(\"2020-02-01\"),\n           y = 45000000000,\n           label = \"Covid19 restriction kicks in\\n in Singapore\",\n           hjust = \"left\",\n           color = \"black\"\n           ) +\n  \n  annotate(geom = \"segment\",\n           x = as.Date(\"2020-05-01\"), \n           y = 44000000000, \n           xend = as.Date(\"2020-03-15\"),  \n           yend = 41500000000,  \n           color = \"grey40\",\n           arrow = arrow(type = \"closed\",\n                         length = unit(0.15, \"inches\"))\n           ) +\n  \n  annotate(geom = \"label\",\n           x = as.Date(\"2020-07-01\"),\n           y = 55000000000,\n           label = \"Trade rebounds\\npost-Covid19 relaxation\",\n           hjust = \"left\",\n           color = \"black\"\n           ) +\n  \n  annotate(geom = \"segment\",\n           x = as.Date(\"2020-10-01\"), \n           y = 54000000000, \n           xend = as.Date(\"2021-02-01\"),  \n           yend = 45000000000,  \n           color = \"grey40\",\n           arrow = arrow(type = \"closed\",\n                         length = unit(0.15, \"inches\"))\n           ) +\n  \n  annotate(geom = \"label\",\n           x = as.Date(\"2021-12-01\"),\n           y = 38000000000,\n           label = \"Start of Russia-Ukraine War\",\n           hjust = \"left\",\n           color = \"black\"\n           ) +\n  \n  annotate(geom = \"segment\",\n           x = as.Date(\"2022-04-01\"), \n           y = 38500000000, \n           xend = as.Date(\"2022-02-01\"),  \n           yend = 43000000000,  \n           color = \"grey40\",\n           arrow = arrow(type = \"closed\",\n                         length = unit(0.15, \"inches\"))\n           ) +\n  \n  annotate(geom = \"label\",\n           x = as.Date(\"2021-08-01\"),\n           y = 58000000000,\n           label = \"3-Year High\\nTrade Activities\",\n           hjust = \"left\",\n           color = \"black\"\n           ) +\n  \n  annotate(geom = \"segment\",\n           x = as.Date(\"2021-12-25\"), \n           y = 58000000000, \n           xend = as.Date(\"2022-06-01\"),  \n           yend = 60000000000,  \n           color = \"grey40\",\n           arrow = arrow(type = \"closed\",\n                         length = unit(0.15, \"inches\"))\n           ) +\n  \n  annotate(geom = \"label\",\n           x = as.Date(\"2022-05-01\"),\n           y = 45000000000,\n           label = \"Recession headwinds\\nresults in trade slumps\",\n           hjust = \"left\",\n           color = \"black\"\n           ) +\n  \n  annotate(geom = \"segment\",\n           x = as.Date(\"2022-09-01\"), \n           y = 46000000000, \n           xend = as.Date(\"2022-08-01\"),  \n           yend = 56000000000,  \n           color = \"grey40\",\n           arrow = arrow(type = \"closed\",\n                         length = unit(0.15, \"inches\"))\n           ) \n\n\n\n\n\n\n\n\n3.1.2 Singapore Trade Balance by Countries\nAfter data wrangling, the main tibble sgtrade_cln still contains data for 52 countries, making it challenging to identify which ones show interesting trends. A horizon graph provides a solution by allowing for the visualization of massive time-series data, providing an overview of the Singapore trade balance for all countries. This is a better alternative than using a trellis line graph which requires the same scale for all countries and may skew user perspective.\nggHoriPlot::geom_horizon() is used to create the horizon graph.\n\n3.1.2.1 Design Consideration\nThe dataset poses a challenge due to the large disparity in trading volume between the largest (Mainland China) and smallest (Cyprus) trading partners. Such imbalanced data can draw focus away from smaller partners, which may offer valuable insights. To strike a balance between the scale of importance (i.e., volume) and patterns, we need to be mindful of these differences. Considerations:\n\nThere are two options to reduce data imbalance to be considered in this plot :\n\nPlotting by normalised trade balance\nPlotting by rate of change of trade balance\n\nRemove outliers when setting the cutpoints to avoid distorting the horizon graph\n\n\n\n\n\n\nTip\n\n\n\nSetting the right cutpoints for horizon graph is important. Hence careful considerations need to be taken with outliers. As such, cutpoints should be set on outlier-free data. This can be done by removing values below the 0.25 quantile - 1.5 times the interquartile range and above the 0.75 quantile + 1.5 times the interquartile range.\nRefer to this article for more details on handling outliers from horizon graph\n\n\nLegends should be removed as the intent of the graph is to detect patterns, hence absolute values are not critical\nOther improvements to enhance visual aesthetics like - having clear title, choosing diverging colorblind-friendly pallete\n\n\n\n3.1.2.2 Preparation of visualisation\n\nCreating normalisation function\nMin-max normalisation is used to convert the data to 0 to 1 scale by applying the following formula\n\\[\n(m - min(m)) / (max(m)-min(m))\n\\]\nAs such, simple function called normalit can be created below\n\n#Creating the normalising function\nnormalit<-function(m){\n   (m - min(m))/(max(m)-min(m))\n }\n\n\n\nData preparation\nA new tibble called sgtrade_cln_hor is created with two new variables:\n\nNormalised_Trade_Balance is created by applying normalit function to Trade_Balance_SGD\nPct_Trade_Balance_Change represents the rate of change (%), is created by calculating the difference between adjacent time-series data for each country. arrange() function is first used to order the tibble based on Countries and Month_Year. The tibble is then grouped by Countries before the new variable is calculated using mutate()\n\n\n\nShow the code\nsgtrade_cln_hor <- sgtrade_cln |> \n  \n  #Calculating the normalised trade balance\n  mutate(Normalised_Trade_Balance = normalit(Trade_Balance_SGD)) |> \n  \n  #Calculating the Rate of Change\n  arrange(Countries, Month_Year) |> \n  group_by(Countries) |> \n  mutate(Pct_Trade_Balance_Change = round((Trade_Balance_SGD - lag(Trade_Balance_SGD))*100/lag(Trade_Balance_SGD), 2)) |> \n  ungroup()\n\n\n\n\nSetting the cutpoints\nggHoriPlot::geom_horizon() requires two important arguments: origin and horizonscale.\nThe code chunks below remove the outliers (defined above) from the sgtrade_cln_hor and store them in new tibble cutpoints or curpoints_roc for normalised plot and rate of change plot respectively.\nOrigin point (ori and ori_roc) is defined as :\n\nFor normalised plot, it is defined when absolute trade balance is zero\nFor rate of change plot, it is defined when the rate of change of trade balance is zero\n\nThe scales (sca and sca_roc) are then defined by dividing range of variables to 8 segments. This is done by using seq() function, specifying length.out argument to be 9; removing the 5th element ([-5]) (to be replaced by origin point).\nRefer to code chunk below for normalised plot\n\n\nShow the code\n#Removing the outliers from cutpoints\ncutpoints <- sgtrade_cln_hor  |>  \n  mutate(\n    outlier = between(\n      Normalised_Trade_Balance, \n      quantile(Normalised_Trade_Balance, 0.25, na.rm=T)-\n        1.5*IQR(Normalised_Trade_Balance, na.rm=T),\n      quantile(Normalised_Trade_Balance, 0.75, na.rm=T)+\n        1.5*IQR(Normalised_Trade_Balance, na.rm=T))) %>% \n  filter(outlier)\n\n#Calculating origin point - when trade balance is 0\nori <- (0 - min(sgtrade_cln_hor$Trade_Balance_SGD))/(max(sgtrade_cln_hor$Trade_Balance_SGD)-min(sgtrade_cln_hor$Trade_Balance_SGD))\n\n#Setting the scales for horizon graph\nsca <- seq(range(cutpoints$Normalised_Trade_Balance)[1], \n           range(cutpoints$Normalised_Trade_Balance)[2], \n           length.out = 9)[-5]\n\n\nRefer to code chunk below for rate of change plot\n\n\nShow the code\n#Removing the outliers from cutpoints\ncutpoints_roc <- sgtrade_cln_hor  |>  \n  mutate(\n    outlier = between(\n      Pct_Trade_Balance_Change, \n      quantile(Pct_Trade_Balance_Change, 0.25, na.rm=T)-\n        1.5*IQR(Pct_Trade_Balance_Change, na.rm=T),\n      quantile(Pct_Trade_Balance_Change, 0.75, na.rm=T)+\n        1.5*IQR(Pct_Trade_Balance_Change, na.rm=T))) %>% \n  filter(outlier)\n\n#Calculating origin point \nori_roc <- 0\n\n#Setting the scales for horizon graph\nsca_roc <- seq(range(cutpoints_roc$Pct_Trade_Balance_Change, na.rm=T)[1], \n           range(cutpoints_roc$Pct_Trade_Balance_Change, na.rm=T)[2], \n           length.out = 9)[-5]\n\n\n\n\nPlotting the main graph\nSteps used to create the two plots:\n\nConvert the Countries variable to factor, ordered by trade volumes in descending order using forcats::fct_reorder()\nBase plot is created using ggHoriPlot::geom_horizon(), specifying the origin and horizonscale arguments as defined above. The show.legend is also specified as FALSE\nSetting the colorblind-friendly diverging palette using scale_fill_hcl()\nFacet the plots by rows using facet_grid()\nAs the x-axis is datetime, scale_x_date() needs to be used, indicating the date_breaks and date_labels format.\nSet the theme and add titles, subtitles, and captions using theme() and labs() functions\n\n\nNormalised Trade BalanceRate of Change of Trade Balance\n\n\n\n\nShow the code\n#Converting countries to factor, ordered by trade volumes in descending order\nsgtrade_cln_hor$Countries <- fct_reorder(sgtrade_cln_hor$Countries, sgtrade_cln_hor$Total_Trade_Volumes_SGD, .desc = TRUE)\n\n#Plotting the base plot\nsgtrade_cln_hor |> ggplot() +\n  geom_horizon(aes(x = Month_Year,\n                   y = Normalised_Trade_Balance,\n                   fill = after_stat(Cutpoints)),\n               origin = ori, horizonscale = sca,\n               show.legend = FALSE) +\n  \n#Setting the color palette\n  scale_fill_hcl(palette = 'RdBu') +\n  \n#Facetted based on Countries\n  facet_grid(Countries~.) +\n\n#Adjusting the scale\n  scale_x_date(expand=c(0,0), \n               date_breaks = \"6 month\",\n               date_labels = \"%b\\n%Y\") +\n  \n#Setting the theme\n  theme_few() +\n  theme(\n    panel.spacing.y=unit(0, \"lines\"),\n    axis.title.x = element_blank(),\n    strip.text.y = element_text(size = 7, angle = 0, hjust = 0),\n    axis.text.y = element_blank(),\n    axis.title.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    panel.border = element_blank(),\n    plot.title = element_text(face = \"bold\")\n    ) +\n\n#Adding title, subtitle, and captions   \n  labs(title = \"Singapore's trade surplus is decreasing against major partners post Covid-19 recovery, except with\\nHong Kong, Indonesia and Thailand\",\n         subtitle = \"Singapore's trade balance against trading partners arranged by trade volumes, 2020 to 2022\",\n         caption = \"Merchandise Trade by Region/Market from Department of Statistics, Singapore\") \n\n\n\n\n\n\n\n\n\nShow the code\n#Converting countries to factor, ordered by trade volumes in descending order\nsgtrade_cln_hor$Countries <- fct_reorder(sgtrade_cln_hor$Countries, sgtrade_cln_hor$Total_Trade_Volumes_SGD, .desc = TRUE)\n\n#Plotting the base plot\nsgtrade_cln_hor |> \n  na.omit() |> \n  ggplot() +\n  geom_horizon(aes(x = Month_Year,\n                   y = Pct_Trade_Balance_Change,\n                   fill = after_stat(Cutpoints)),\n               origin = ori_roc, horizonscale = sca_roc,\n               show.legend = FALSE) +\n  \n#Setting the color palette\n  scale_fill_hcl(palette = 'RdBu') +\n  \n#Facetted based on Countries\n  facet_grid(Countries~.) +\n  \n#Adjusting the scale\n  scale_x_date(expand=c(0,0), \n               date_breaks = \"6 month\",\n               date_labels = \"%b\\n%Y\") +\n  \n#Setting the theme\n  theme_few() +\n  theme(\n    panel.spacing.y=unit(0, \"lines\"),\n    axis.title.x = element_blank(),\n    strip.text.y = element_text(size = 7, angle = 0, hjust = 0),\n    axis.text.y = element_blank(),\n    axis.title.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    panel.border = element_blank(),\n    plot.title = element_text(face = \"bold\")\n    ) +\n  \n#Adding title, subtitle, and captions   \n  labs(title = \"Volatile changes in Singapore's trade balance against major partners, except with\\nTaiwan, Hong Kong, and Indonesia\",\n         subtitle = \"Singapore's trade balance change (MoM%) against trading partners arranged by trade volumes, 2020 to 2022\",\n         caption = \"Merchandise Trade by Region/Market from Department of Statistics, Singapore\") \n\n\n\n\n\n\n\n\n\n\n\n3.1.2.3 Insights\n\nNormalised Trade Balance Plot\n\nDespite normalization, smaller partners can still be overshadowed by larger ones. To balance the scale of importance and patterns, the plot can guide the filtering out of certain trading partners. Based on the graph, we should not consider trading partners with lower trading volumes than Sri Lanka.\n\n\n\nRate of Change of Trade Balance Plot\n\nThis plot provides a more balanced visualization between smaller and larger trading partners. However, it’s important to note that smaller trading partners exhibit higher intensity, which is expected as small changes in trading balance are overexaggerated due to their smaller volume\n\nSingapore’s trading partners are diverse and can be broadly categorized into Major Partners, Other Regional Partners, European Partners, and Other Minor Partners. For this analysis, 16 countries were selected around the categories based on the following interesting observations:\n\nTable 1: List of Selected Countries\n\n\n\n\n\n\n\n\nCategory\nCountry\nNormalised Plot\nRate of Change Plot\n\n\n\n\nMajor Partners\nMainland China\n(Largest partner)\nProminent swing from surplus to deficit in Q2 2022\nHigh volatility before mid-2021 and after 2022\n\n\nMajor Partners\nMalaysia\n(Largest ASEAN partner)\nConstant trade deficit but starts to reduce in Q2 2022\nSimilar observation\n\n\nMajor Partners\nUnited States\n(Largest Western partner)\nSwing from surplus to deficit from Q2 2021\nHigh volatility throughout with dominant negative rate of change in Q2 2021 and 2022\n\n\nMajor Partners\nSouth Korea\nLarge trade deficit starts in Q3 2021\nProminent negative change preceding the deficit in Q2 2021\n\n\nOther Regional Partners\nAustralia\nStrong trade surplus recovery from Q2 2021\nStrongly turns positive preceding the trade surplus few months before\n\n\nOther Regional Partners\nIndia\nTwo major dips in early 2020 and mid 2021\nStronger trade balance recovery post 2020 dip vs 2021\n\n\nOther Regional Partners\nPhilippines\nProminent trade surplus from Q3 2022\nHigh volatility prior to Q3 2022\n\n\nOther Regional Partners\nCambodia\nLarge three export gains in Q1, Q3 2021, and Q2 2022\nSimilar observation with negative change prior to that\n\n\nEuropean Partners\nGermany\n(Largest European partner)\nReducing trade deficit from Q3 2022\nSame observation with prominent single positive change in Q2 2021\n\n\nEuropean Partners\nFrance\nTurns dominant deficit since Q1 2021\n…but preceded by largely positive change\n\n\nEuropean Partners\nSwitzerland\nTurns dominant deficit since Q2 2021\n…but there are spikes of positive change, indicating volatility in trade balance\n\n\nEuropean Partners\nUnited Kingdom\nSlight trade surplus in Q2 2020 aside from deficit in other period\n…followed by dominant negative change\n\n\nOther Minor Partners\nMexico\nMaintaining very close trade balance\n… but marked by high volatility post Q2 2021\n\n\nOther Minor Partners\nNew Zealand\nProminent trade surplus since Q2 2022\nSame observation\n\n\nOther Minor Partners\nCanada\nSmall deficit peak in Q3 2022\nSame observation in Q3 2022 with opposite impact in Q3 2020\n\n\nOther Minor Partners\nBrunei Darussalam\nTurns slight negative post Q2 2021 with small deficit peak in Q2 2022\nHigh volatility from end 2020 to mid 2021\n\n\n\n\n\n\n\n\n\n\n\n3.2 Bi-lateral Trade of Singapore against selected partners\n\n3.2.1 Singapore Trade Balance Performance\n\nOverall SingaporeSelected Countries\n\n\n\n\nShow the code\ntotalsgtrade_calmap <- totalsgtrade |> \n  mutate(Month = factor(format(Month_Year,\"%b\")), .after = Year) |> \n  mutate(Trade_Balance = (Export - Import)/1000000000)\n\nggplot(totalsgtrade_calmap |> \n         mutate(Year = factor(Year, levels =c(2022,2021,2020))), \n       aes(x = Month, \n           y = Year, \n           fill = Trade_Balance)) + \n  \ngeom_tile(color = \"white\") + \n  \nscale_fill_gradientn(name = \"Trade Balance (Billions SGD)\",\n                     colors=c(\"#D55E00\",\"grey90\",\"#0072B2\"),\n                     values=rescale(c(min(totalsgtrade_calmap$Trade_Balance),0,max(totalsgtrade_calmap$Trade_Balance))),\n                     limits=c(min(totalsgtrade_calmap$Trade_Balance),max(totalsgtrade_calmap$Trade_Balance))) +\ncoord_equal() +\n  \nlabs(x = NULL, \n     y = NULL, \n     title = \"Singapore's trade surplus declines in 2022; turning slightly negative in May 2022\",\n     subtitle = \"Singapore Trade Balance by calendar months, 2020-2022\",\n     caption = \"Merchandise Trade by Region/Market from Department of Statistics, Singapore\") +\n  \ntheme_tufte(base_family = \"Helvetica\") +\n  \ntheme(axis.ticks = element_blank(),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6),\n      plot.title = element_text(face = \"bold\"))\n\n\n\n\n\n\n\n\n\nShow the code\nselected_countries = c(\"Mainland China\", \"Malaysia\", \"United States\", \"South Korea\", \"Australia\", \"India\", \"Philippines\", \"Cambodia\", \"Germany\", \"France\", \"Switzerland\", \"United Kingdom\", \"Mexico\", \"New Zealand\", \"Canada\", \"Brunei Darussalam\")\n\nsgtrade_calmap <- sgtrade_cln |> \n  mutate(Trade_Balance = Trade_Balance_SGD/1000000000)\n\nsgtrade_calmap$Countries <- fct_reorder(sgtrade_calmap$Countries, sgtrade_calmap$Total_Trade_Volumes_SGD, .desc = TRUE)\n\nggplot(sgtrade_calmap |> \n         mutate(Year = factor(Year, levels =c(2022,2021,2020))) |> \n         filter(Countries %in% selected_countries), \n       aes(x = Month, \n           y = Year, \n           fill = Trade_Balance)) + \n  \ngeom_tile(color = \"white\") + \n  \nscale_fill_gradientn(name = \"Trade Balance (Billions SGD)\",\n                     colors=c(\"#D55E00\",\"grey90\",\"#0072B2\"),\n                     values=rescale(c(min(sgtrade_calmap$Trade_Balance),0,max(sgtrade_calmap$Trade_Balance))),\n                     limits=c(min(sgtrade_calmap$Trade_Balance),max(sgtrade_calmap$Trade_Balance))) +\ncoord_equal() +\n  \nfacet_wrap(~Countries, ncol = 2) +\n  \nlabs(x = NULL, \n     y = NULL, \n     title = \"Singapore's trade balance post Covid recovery: Turns <span style = 'color:#D55E00'>Negative</span> with China, USA, and South Korea;<br><span style = 'color:#0072B2'>Positive</span> with Cambodia\",\n     subtitle = \"Singapore Trade Balance against selected partners by calendar months, 2020-2022\",\n     caption = \"Merchandise Trade by Region/Market from Department of Statistics, Singapore\") +\n  \ntheme_tufte(base_family = \"Helvetica\") +\n  \ntheme(axis.ticks = element_blank(),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6),\n      plot.title = element_markdown(face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n3.2.2 Singapore Trade Export and Import\n\n\nShow the code\nplot_braid_ctry <- function(selected_countries, showlegend) {\n\nsgtrade_cln$Countries <- fct_reorder(sgtrade_cln$Countries, sgtrade_cln$Total_Trade_Volumes_SGD, .desc = TRUE)\n\n#\nsgtrade_cln_long <- sgtrade_cln |> \n  select(Month_Year, Countries, Year, Import_SGD, Export_SGD, Pct_Total_Trade_Volumes) |> \n  pivot_longer(cols = c(Import_SGD, Export_SGD),\n               names_to = \"Type\",\n               values_to = \"Values\")\n\navg_total_ctry_2020 <- sgtrade_cln |> \n  filter(Year == 2020) |> \n  group_by (Year, Countries) |> \n  summarise(import = mean(Import_SGD),\n            export = mean(Export_SGD)) |> \n  mutate(Year_date = as.Date(paste(Year, \"-01-01\", sep = \"\"))) |> \n  rowwise() |> mutate(min_import_export = min(import, export))\n\n\n#creating label\nlabel_ctry <- sgtrade_top_ctry |> \n  filter(Countries %in% selected_countries)\n  \nCtry_labels <- paste0(\"\\n\",label_ctry$Pct_Total_Trade_Volumes,\"% of Total Volumes\")\n\nappender <- function(string, suffix = Ctry_labels) paste0(string, suffix)\n\n\n#Plotting\nggplot(data = sgtrade_cln_long |> \n         filter(Countries %in% selected_countries)) +\n  \n  geom_line(data = sgtrade_cln_long |> \n              filter(Countries %in% selected_countries),\n            aes(x = Month_Year,\n                y = Values,\n                color = Type),\n            linewidth = 1.2,\n            show.legend = showlegend) +\n  \n  geom_braid(data = sgtrade_cln |> \n              filter(Countries %in% selected_countries),\n             aes(x = Month_Year,\n                 ymin = Import_SGD,\n                 ymax = Export_SGD,\n                 fill = Import_SGD < Export_SGD),\n             alpha = 0.5) +\n  \n  guides(linetype = \"none\", fill = \"none\") +\n  \n  geom_hline(data = avg_total_ctry_2020|> \n              filter(Countries %in% selected_countries),\n             aes(yintercept = export), \n             col = \"#0072B2\",\n             linewidth=0.8,\n             linetype = \"dashed\") +\n  \n  geom_hline(data = avg_total_ctry_2020|> \n               filter(Countries %in% selected_countries),\n             aes(yintercept = import), \n             col = \"#D55E00\",\n             linewidth=0.8,\n             linetype = \"dashed\") +\n  \n  geom_text(data = avg_total_ctry_2020|> \n               filter(Countries %in% selected_countries),\n            aes(x = Year_date,\n                y = min_import_export - 0.25*min_import_export,\n                label = \"Avg 2020\"),\n            size = 3.5,\n            nudge_x = +920) +\n  \n  scale_color_manual(values = c(\"#0072B2\", \"#D55E00\"),\n                     labels = c(\"Export\", \"Import\"),\n                     name = NULL) +\n  \n  scale_fill_manual(values = c(\"#E69F00\", \"#56B4E9\")) +\n  \n  scale_x_date(expand = c(0,0),\n               limits = c(as.Date(\"2020-01-01\"),as.Date(\"2022-12-31\")),\n               date_breaks = \"1 year\",\n               date_labels = \"%Y\") +\n  \n  scale_y_continuous(\"Trade Values\",\n                     labels = function(x){paste0('$', abs(x/1000000000),'B')}) +\n    \n  facet_wrap(vars(Countries), ncol=4, labeller=as_labeller(appender)) +\n  \n  cowplot::theme_cowplot() +\n  \n  theme(axis.title.x = element_blank(),\n        panel.grid.major.y = element_line(color = \"grey90\", linetype = \"solid\"),\n        panel.border = element_rect(color = \"grey60\", linetype = \"solid\", linewidth = 0.5),\n        panel.spacing.x = unit(0,\"line\"),\n        panel.spacing.y = unit(0,\"line\")) \n\n}\n\n\nPlotting the graph\n\n\nShow the code\n#Specifying the annotation for p1\np1_text <- data.frame(label = c(\"Zero Covid Policy\\nWar in Ukraine\", \"\", \"War in Ukraine\", \"Covid recovery\"),  \n                         Countries = c(\"Mainland China\", \"Malaysia\", \"United States\", \"South Korea\"),\n                         x = c(as.Date(\"2021-01-01\"), 0, as.Date(\"2021-01-01\"), as.Date(\"2020-10-01\")),\n                         y = c(1500000000, 0, 1500000000, 7500000000))\n\narrowp1<- data.frame(Countries = c(\"Mainland China\", \"Malaysia\", \"United States\", \"South Korea\"),\n                      x = c(as.Date(\"2021-01-01\"), 0, as.Date(\"2021-01-01\"), as.Date(\"2020-10-01\")),\n                      y = c(2700000000, 0, 2100000000, 7000000000),\n                      xend = c(as.Date(\"2022-02-01\"), 0, as.Date(\"2022-02-01\"), as.Date(\"2021-04-01\")),\n                      yend = c(4500000000, 0, 4100000000, 2500000000))\n\np1_text$Countries <- factor(c(\"Mainland China\", \"Malaysia\", \"United States\", \"South Korea\"))\n\narrowp1$Countries <- factor(c(\"Mainland China\", \"Malaysia\", \"United States\", \"South Korea\"))\n\n#Specifying the annotation for p2\np2_text <- data.frame(label = c(\"Start of\\nrecession\", \"Covid Waves\", \"Start of\\nrecession\", \"Reversal in\\nBalance\"),  \n                         Countries = c(\"Australia\", \"India\", \"Philippines\", \"Cambodia\"),\n                         x = c(as.Date(\"2020-08-01\"), as.Date(\"2020-10-01\"), as.Date(\"2020-08-01\"), as.Date(\"2020-09-01\")),\n                         y = c(2000000000, 2000000000, 2000000000, 2000000000))\n\narrowp2<- data.frame(Countries = c(\"Australia\", \"India\", \"Philippines\", \"Cambodia\"),\n                      x = c(as.Date(\"2021-02-01\"), as.Date(\"2020-10-01\"), as.Date(\"2021-02-01\"), as.Date(\"2020-09-01\")),\n                      y = c(2000000000, 1850000000, 2000000000, 1700000000),\n                      xend = c(as.Date(\"2022-07-01\"), as.Date(\"2020-04-01\"), as.Date(\"2022-07-01\"), as.Date(\"2020-10-01\")),\n                      yend = c(2000000000, 600000000, 1400000000, 200000000))\n\narrowp2a<- data.frame(Countries = c(\"Australia\", \"India\", \"Philippines\", \"Cambodia\"),\n                      x = c(as.Date(\"1970-01-01\"), as.Date(\"2020-10-01\"), 0, 0),\n                      y = c(0, 1850000000, 0, 0),\n                      xend = c(as.Date(\"1970-01-01\"), as.Date(\"2021-06-01\"), 0, 0),\n                      yend = c(0, 1100000000, 0, 0))\n\np2_text$Countries <- factor(c(\"Australia\", \"India\", \"Philippines\", \"Cambodia\"))\n\narrowp2$Countries <- factor(c(\"Australia\", \"India\", \"Philippines\", \"Cambodia\"))\n\narrowp2a$Countries <- factor(c(\"Australia\", \"India\", \"Philippines\", \"Cambodia\"))\n\n#Specifying the annotation for p3\np3_text <- data.frame(label = c(\"Start of\\nrecession\", \"\", \"\", \"Surge in\\nExports\"),  \n                         Countries = c(\"Germany\", \"France\", \"Switzerland\", \"United Kingdom\"),\n                         x = c(as.Date(\"2020-9-01\"), 0, 0, as.Date(\"2022-6-01\")),\n                         y = c(1700000000, 0, 0, 1700000000))\n\narrowp3<- data.frame(Countries = c(\"Germany\", \"France\", \"Switzerland\", \"United Kingdom\"),\n                      x = c(as.Date(\"2021-3-01\"), 0, 0, as.Date(\"2022-01-01\")),\n                      y = c(1700000000, 0, 0, 1700000000),\n                      xend = c(as.Date(\"2022-08-01\"), 0, 0, as.Date(\"2020-09-01\")),\n                      yend = c(1300000000, 0, 0, 1200000000))\n\np3_text$Countries <- factor(c(\"Germany\", \"France\", \"Switzerland\", \"United Kingdom\"))\n\narrowp3$Countries <- factor(c(\"Germany\", \"France\", \"Switzerland\", \"United Kingdom\"))\n\n#Specifying the annotation for p4\np4_text <- data.frame(label = c(\"Reduced Trade\\nDeficit\", \"Enhanced\\nPartnership\", \"\", \"\"),  \n                         Countries = c(\"Mexico\", \"New Zealand\", \"Canada\", \"Brunei Darussalam\"),\n                         x = c(as.Date(\"2020-12-01\"), as.Date(\"2020-10-01\"), 0, 0),\n                         y = c(600000000, 600000000, 0, 0))\n\narrowp4<- data.frame(Countries = c(\"Mexico\", \"New Zealand\", \"Canada\", \"Brunei Darussalam\"),\n                      x = c(as.Date(\"2021-9-01\"), as.Date(\"2021-05-01\"), 0, 0),\n                      y = c(600000000, 600000000, 0, 0),\n                      xend = c(as.Date(\"2022-02-01\"), as.Date(\"2022-03-01\"), 0, 0),\n                      yend = c(250000000, 300000000, 0, 0))\n\np4_text$Countries <- factor(c(\"Mexico\", \"New Zealand\", \"Brunei Darussalam\", \"Canada\"))\n\narrowp4$Countries <- factor(c(\"Mexico\", \"New Zealand\", \"Brunei Darussalam\", \"Canada\"))\n\n#Plotting the graph\np1a <- plot_braid_ctry(c(\"Mainland China\", \"Malaysia\", \"United States\", \"South Korea\"), showlegend = FALSE)\np1 <- p1a + \n  geom_label(data = p1_text,\n            aes(x = x,\n                y = y,\n                label = label)) +\n  geom_segment(data = arrowp1, \n               aes(x = x, xend = xend, y = y, yend = yend), \n               colour = \"black\", alpha=0.9, arrow = arrow(type = \"closed\",length = unit(0.1, \"inches\"))) +\n  labs(subtitle = \"Singapore merchandise trade volume with ***major partners*** rebounds amid Covid-19 recovery, but deficit worsens;<br>recession shrinks trade further in mid-2022\") +\n  theme(plot.subtitle = element_markdown())\n\np2a <- plot_braid_ctry(c(\"Australia\", \"India\", \"Philippines\", \"Cambodia\"), showlegend = FALSE)\np2 <- p2a + \n  geom_label(data = p2_text,\n            aes(x = x,\n                y = y,\n                label = label)) +\n  geom_segment(data = arrowp2, \n               aes(x = x, xend = xend, y = y, yend = yend), \n               colour = \"black\", alpha=0.9, arrow = arrow(type = \"closed\",length = unit(0.1, \"inches\"))) +\n  geom_segment(data = arrowp2a, \n               aes(x = x, xend = xend, y = y, yend = yend), \n               colour = \"black\", alpha=0.9, arrow = arrow(type = \"closed\",length = unit(0.1, \"inches\"))) +\n  labs(subtitle = \"Exports bounced back with ***other regional partners*** with Covid-19 recovery; but hit by recession in 2022\") +\n  theme(plot.subtitle = element_markdown())\n\np3a <- plot_braid_ctry(c(\"Germany\", \"France\", \"Switzerland\", \"United Kingdom\"), showlegend = FALSE)\np3 <- p3a + \n  geom_label(data = p3_text,\n            aes(x = x,\n                y = y,\n                label = label)) +\n  geom_segment(data = arrowp3, \n               aes(x = x, xend = xend, y = y, yend = yend), \n               colour = \"black\", alpha=0.9, arrow = arrow(type = \"closed\",length = unit(0.1, \"inches\"))) +\n  labs(subtitle = \"Imports rise and volatility worsens amid Covid-19 recovery, but exports to ***major European partners*** stay sluggish\") +\n  theme(plot.subtitle = element_markdown())\n\np4a <- plot_braid_ctry(c(\"Mexico\", \"New Zealand\", \"Canada\", \"Brunei Darussalam\"), showlegend = FALSE)\np4 <- p4a + \n  geom_label(data = p4_text,\n             aes(x = x,\n                 y = y,\n                 label = label)) +\n  geom_segment(data = arrowp4, \n               aes(x = x, xend = xend, y = y, yend = yend), \n               colour = \"black\", alpha=0.9, arrow = arrow(type = \"closed\",length = unit(0.1, \"inches\"))) +\n  labs(subtitle = \"Trade volume also makes recovery with ***minor partners*** in 2022, with exports growing to Mexico and New Zealand\") +\n  theme(plot.subtitle = element_markdown())\n\n\nfinal_plot <- p1 / p2 / p3 / p4\n\nfinal_plot + plot_annotation(\n  title = \"Merchandise <span style = 'color:#0072B2'>Export</span> and <span style = 'color:#D55E00'>Import</span> Trade Values of Singapore (in SGD)<br>by selected trading partners, 2020-2022\",\n  caption = \"Merchandise Trade by Region/Market from Department of Statistics, Singapore\",\n  theme = theme(plot.title = element_markdown(face = \"bold\", size = 18))\n)\n\n\n\n\n\n\n\n3.2.3 Year-over-Year changes between 2020 and 2022\nChoose Q3 as Q3 2020 is during the major lockdowns around the world and it is just prior to recession in 2022. Providing a bit of stability in the data\nModifying the data\n\nsgtrade_cln_qtr <- sgtrade_cln |> \n  mutate(Quarter = factor(paste0(\"Q\", quarter(Month_Year), \" \", year(Month_Year))), .after = Month) |> \n  filter(Quarter %in% c(\"Q3 2020\", \"Q3 2022\")) |> \n  group_by(Countries, Quarter) |> \n  summarise(Total_Trade_Balance_BSGD = round(sum(Trade_Balance_SGD)/1000000000, 2),\n            Total_Trade_Volumes_BSGD = round(sum(Trade_Volumes_SGD)/1000000000, 2),\n            Total_Import_BSGD = round(sum(Import_SGD)/1000000000, 2),\n            Total_Export_BSGD = round(sum(Export_SGD)/1000000000, 2))\n\nsgtrade_cln_qtr\n\n# A tibble: 104 × 6\n# Groups:   Countries [52]\n   Countries  Quarter Total_Trade_Balance_BSGD Total_Trade_Vol…¹ Total…² Total…³\n   <chr>      <fct>                      <dbl>             <dbl>   <dbl>   <dbl>\n 1 Australia  Q3 2020                     1.98              4.37    1.2     3.18\n 2 Australia  Q3 2022                     3.17              9.31    3.07    6.24\n 3 Austria    Q3 2020                    -0.14              0.28    0.21    0.07\n 4 Austria    Q3 2022                    -0.23              0.48    0.35    0.13\n 5 Bahrain    Q3 2020                    -0.13              0.17    0.15    0.02\n 6 Bahrain    Q3 2022                    -0.08              0.28    0.18    0.1 \n 7 Bangladesh Q3 2020                     0.74              0.85    0.06    0.79\n 8 Bangladesh Q3 2022                     1.56              1.71    0.07    1.64\n 9 Belgium    Q3 2020                     0.75              1.32    0.28    1.04\n10 Belgium    Q3 2022                     1.38              2.52    0.57    1.95\n# … with 94 more rows, and abbreviated variable names\n#   ¹​Total_Trade_Volumes_BSGD, ²​Total_Import_BSGD, ³​Total_Export_BSGD\n\n\nCreating function to plot Trade Balances\n\nTrade VolumeImportExportTrade Balance\n\n\n\nplot_slopegraph_tradevol <- function(selected_countries) {\n  \n  custom_colors_tradevol <- sgtrade_cln_qtr |> \n    pivot_wider(id_cols = Countries,\n                names_from = Quarter,\n                values_from = Total_Trade_Volumes_BSGD) |> \n    mutate(diff_Total_Trade_Volumes = `Q3 2022` - `Q3 2020`) |> \n    mutate(col_Total_Trade_Volumes = case_when(\n      diff_Total_Trade_Volumes > 5 ~\"#0072B2\",\n      diff_Total_Trade_Volumes <= -3 ~\"#D55E00\",\n      TRUE ~ \"grey\"\n    )) |> \n    select(Countries, col_Total_Trade_Volumes) |> \n    deframe()\n  \n  newggslopegraph(dataframe = sgtrade_cln_qtr |> \n                    filter(Countries %in% selected_countries),\n                  Times = Quarter,\n                  Measurement = Total_Trade_Volumes_BSGD,\n                  Grouping = Countries,\n                  Title = \"Y-o-Y Change in Singapore Merchandise Trade Volumes (Billion SGD)\",\n                  SubTitle = \"Q3 2020 to Q3 2022\",\n                  Caption = \"Merchandise Trade by Region/Market from Department of Statistics, Singapore\",\n                  LineColor = custom_colors_tradevol,\n                  LineThickness = 0.7,\n                  ThemeChoice = \"gdocs\",\n                  WiderLabels = TRUE)\n}\n\n\n\n\nplot_slopegraph_import <- function(selected_countries) {\n  \n  custom_colors_import <- sgtrade_cln_qtr |> \n    pivot_wider(id_cols = Countries,\n                names_from = Quarter,\n                values_from = Total_Import_BSGD) |> \n    mutate(diff_Total_Import = `Q3 2022` - `Q3 2020`) |> \n    mutate(col_Total_Import = case_when(\n      diff_Total_Import > 1 ~\"#D55E00\",\n      diff_Total_Import <= -1 ~\"#0072B2\",\n      TRUE ~ \"grey\"\n    )) |> \n    select(Countries, col_Total_Import) |> \n    deframe()\n  \n  newggslopegraph(dataframe = sgtrade_cln_qtr |> \n                    filter(Countries %in% selected_countries),\n                  Times = Quarter,\n                  Measurement = Total_Import_BSGD,\n                  Grouping = Countries,\n                  Title = \"Y-o-Y Change in Singapore Merchandise Import Values (Billion SGD)\",\n                  SubTitle = \"Q3 2020 to Q3 2022\",\n                  Caption = \"Merchandise Trade by Region/Market from Department of Statistics, Singapore\",\n                  LineColor = custom_colors_import,\n                  LineThickness = 0.7,\n                  ThemeChoice = \"gdocs\",\n                  WiderLabels = TRUE)\n}\n\n\n\n\nplot_slopegraph_export <- function(selected_countries) {\n  \n  custom_colors_export <- sgtrade_cln_qtr |> \n    pivot_wider(id_cols = Countries,\n                names_from = Quarter,\n                values_from = Total_Export_BSGD) |> \n    mutate(diff_Total_Export = `Q3 2022` - `Q3 2020`) |> \n    mutate(col_Total_Export = case_when(\n      diff_Total_Export > 1 ~\"#0072B2\",\n      diff_Total_Export <= -1 ~\"#D55E00\",\n      TRUE ~ \"grey\"\n    )) |> \n    select(Countries, col_Total_Export) |> \n    deframe()\n  \n  newggslopegraph(dataframe = sgtrade_cln_qtr |> \n                    filter(Countries %in% selected_countries),\n                  Times = Quarter,\n                  Measurement = Total_Export_BSGD,\n                  Grouping = Countries,\n                  Title = \"Y-o-Y Change in Singapore Merchandise Export Values (Billion SGD)\",\n                  SubTitle = \"Q3 2020 to Q3 2022\",\n                  Caption = \"Merchandise Trade by Region/Market from Department of Statistics, Singapore\",\n                  LineColor = custom_colors_export,\n                  LineThickness = 0.7,\n                  ThemeChoice = \"gdocs\",\n                  WiderLabels = TRUE)\n}\n\n\n\n\nplot_slopegraph_tradebal <- function(selected_countries) {\n  \n  custom_colors_tradebal <- sgtrade_cln_qtr |> \n    pivot_wider(id_cols = Countries,\n                names_from = Quarter,\n                values_from = Total_Trade_Balance_BSGD) |> \n    mutate(diff_Total_Trade_Balance = `Q3 2022` - `Q3 2020`) |> \n    mutate(col_Total_Trade_Balance = case_when(\n      diff_Total_Trade_Balance > 0.5 ~\"#0072B2\",\n      diff_Total_Trade_Balance <= -0.5 ~\"#D55E00\",\n      TRUE ~ \"grey\"\n    )) |> \n    select(Countries, col_Total_Trade_Balance) |> \n    deframe()\n  \n  newggslopegraph(dataframe = sgtrade_cln_qtr |> \n                    filter(Countries %in% selected_countries),\n                  Times = Quarter,\n                  Measurement = Total_Trade_Balance_BSGD,\n                  Grouping = Countries,\n                  Title = \"Y-o-Y Change in Singapore Merchandise Trade Balance (Billion SGD)\",\n                  SubTitle = \"Q3 2020 to Q3 2022\",\n                  Caption = \"Merchandise Trade by Region/Market from Department of Statistics, Singapore\",\n                  LineColor = custom_colors_tradebal,\n                  LineThickness = 0.7,\n                  ThemeChoice = \"gdocs\",\n                  WiderLabels = TRUE)\n}\n\n\n\n\n\nTrade VolumeImportExportTrade Balance\n\n\n\n\nShow the code\nplot_slopegraph_tradevol(c(\"Mainland China\", \"Malaysia\", \"United States\", \"South Korea\", \"Australia\", \"India\", \"Philippines\", \"Cambodia\", \"Germany\", \"France\", \"Switzerland\", \"United Kingdom\", \"Mexico\", \"New Zealand\", \"Canada\", \"Brunei Darussalam\"))\n\n\n\n\n\n\n\n\n\nShow the code\nplot_slopegraph_import(c(\"Mainland China\", \"Malaysia\", \"United States\", \"South Korea\", \"Australia\", \"India\", \"Philippines\", \"Cambodia\", \"Germany\", \"France\", \"Switzerland\", \"United Kingdom\", \"Mexico\", \"New Zealand\", \"Canada\", \"Brunei Darussalam\"))\n\n\n\n\n\n\n\n\n\nShow the code\nplot_slopegraph_export(c(\"Mainland China\", \"Malaysia\", \"United States\", \"South Korea\", \"Australia\", \"India\", \"Philippines\", \"Cambodia\", \"Germany\", \"France\", \"Switzerland\", \"United Kingdom\", \"Mexico\", \"New Zealand\", \"Canada\", \"Brunei Darussalam\"))\n\n\n\n\n\n\n\n\n\nShow the code\nplot_slopegraph_tradebal(c(\"Mainland China\", \"Malaysia\", \"United States\", \"South Korea\", \"Australia\", \"India\", \"Philippines\", \"Cambodia\", \"Germany\", \"France\", \"Switzerland\", \"United Kingdom\", \"Mexico\", \"New Zealand\", \"Canada\", \"Brunei Darussalam\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.3 Changes in Import and Export over time\n\n3.3.1 Data Preparation\n\n\nShow the code\nregions_cln <- regions |> \n    mutate(Countries = case_when(Countries == \"Brunei\" ~ \"Brunei Darussalam\",\n                                 Countries == \"Czechia\" ~ \"Czech Republic\",\n                                 Countries == \"China\" ~ \"Mainland China\",\n                                 TRUE~Countries))\n\nsgtrade_cln_ani <- sgtrade_cln |> \n  select(Month_Year, Countries, Import_SGD, Export_SGD, Trade_Volumes_SGD) |> \n  \n  mutate(Import_SGD = round(Import_SGD/1000000000, 1),\n         Export_SGD = round(Export_SGD/1000000000, 1),\n         Trade_Volumes_SGD = round(Trade_Volumes_SGD/1000000000, 1)) |> \n  \n  left_join(regions_cln, by = c('Countries' = 'Countries'))\n\nsgtrade_cln_ani\n\n\n# A tibble: 1,872 × 6\n   Month_Year Countries Import_SGD Export_SGD Trade_Volumes_SGD Region          \n   <date>     <chr>          <dbl>      <dbl>             <dbl> <chr>           \n 1 2022-12-01 Belgium          0.1        0.4               0.5 Europe and Cent…\n 2 2022-11-01 Belgium          0.1        0.8               0.9 Europe and Cent…\n 3 2022-10-01 Belgium          0.1        0.4               0.4 Europe and Cent…\n 4 2022-09-01 Belgium          0.2        0.4               0.6 Europe and Cent…\n 5 2022-08-01 Belgium          0.1        0.6               0.7 Europe and Cent…\n 6 2022-07-01 Belgium          0.2        1                 1.2 Europe and Cent…\n 7 2022-06-01 Belgium          0.1        0.6               0.7 Europe and Cent…\n 8 2022-05-01 Belgium          0.1        0.6               0.7 Europe and Cent…\n 9 2022-04-01 Belgium          0.1        0.7               0.8 Europe and Cent…\n10 2022-03-01 Belgium          0.3        1.4               1.8 Europe and Cent…\n# … with 1,862 more rows\n\n\n\n\n3.3.2 Building the plot\n\n\nShow the code\npa <- ggplot(data = sgtrade_cln_ani,\n       aes(x = Import_SGD,\n           y = Export_SGD,\n           color = Region)) +\n  \n  geom_point(aes(size = Trade_Volumes_SGD),\n             alpha = 0.7,\n             show.legend = F) +\n  \n  geom_abline(intercept = 0, \n              slope = 1,\n              linewidth = 0.7,\n              alpha = 0.7,\n              linetype = \"dashed\",\n              col = \"grey40\") +\n  \n  geom_label(aes(label = Countries,\n                      group = Countries),\n                  show.legend = FALSE,\n                  size = 3) +\n  \n  scale_size(range = c(5,45)) +\n  \n  scale_x_log10() +\n  scale_y_log10() +\n  \n  labs(title = 'Singapore Merchandise Export vs Import Trade Values from 2020 to 2022',\n       subtitle = \"Period: {format(frame_time, '%b %Y')}\",\n       x = 'Import (Billion SGD)', \n       y = 'Export (Billion SGD)') +\n  \n  theme(plot.title = element_text(size = 18, face = \"bold\")) +\n  \n  transition_time(Month_Year) + \n  \n  ease_aes('linear') \n\nanimate(pa, \n        duration = 25, #12 months/Year x 3 years x 0.7 sec/months = 18 seconds\n        height = 800, \n        width = 800,\n        fps = 30)"
  }
]